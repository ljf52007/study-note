`CSS(3)`中提供的选择器手册`(w3school)`：http://www.w3school.com.cn/cssref/css_selectors.asp

## 基本选择器

| 选择器     | 例子                                                         |
| ---------- | ------------------------------------------------------------ |
| 类选择器   | `.class`                                                     |
| 标签选择器 | `div`                                                        |
| id选择器   | `#id`                                                        |
| 后代选择器 | `div p`：选择 `div` 内部的全部 `p` 元素                      |
| 子代选择器 | `div > p`：选择以 `div` 为父元素的全部 `p` 元素              |
| 群组选择器 | `div,p`：选择 `div` 和 `p`                                   |
| 相邻选择器 | `div + p`：选择与 `div` 相邻的，并且元素类型为 `p` 的元素，相邻和`p`类型，两个条件都要满足，缺一不可 |
| 兄弟选择器 | `div ~ p`：选择`div`的兄弟元素，且元素类型为`p`              |



## 属性选择器

| 写法          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `[attr]`      | 选择存在`attr`属性的元素，如果想要限制元素类型，则可以写成 `E[attr]`，下同 |
| `[attr=val]`  | 选择属性值完全等于`val`的元素，引号可加可不加                |
| `[attr*=val]` | 选择属性值里包含`val`字符的元素                              |
| `[attr^=val]` | 选择属性值里以`val`字符开头的元素                            |
| `[attr$=val]` | 选择属性值里以`val`字符结尾的元素                            |



## 伪类选择器

> 伪类存在的意义是为了通过选择器找到那些不存在`DOM`树中的信息以及不能被常规`CSS`选择器获取到的信息

1. 获取不存在与`DOM`树中的信息。比如`a`标签的`:link`、`visited`等，这些信息不存在与`DOM`树结构中，只能通过`CSS`选择器来获取；
2. 获取不能被常规`CSS`选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的`CSS`选择器获取，但可以通过 `:first-child` 来获取到。

### 超链接伪类选择器

| 写法        | 说明                        |
| ----------- | --------------------------- |
| `a:link`    | 定义`a`元素未访问时的样式   |
| `a:visited` | 定义`a`元素访问后的样式     |
| `a:hover`   | 定义鼠标经过`a`元素时的样式 |
| `a:active`  | 定义鼠标点击`a`激活时的样式 |

注意：

1. 在定义这四个伪类的时候，要按照` link、visited、hover、active` 的顺序进行，即“爱恨原则”——`LoVe HAte`:
   - 当鼠标划过`a`链接时,`a`链接同时满足`:link`和`:hover`两种状态,因此,要改变`a`链接的样式,就必须把`:hover`放在`:link`之后;
   - 当鼠标点击`a`链接时,`a`链接同时满足`:link`,`:hover`和`active`三种状态.因此,要改变`a`链接的样式,就必须把`:active`放在`:link`和`:hover`之后;
   - 当`a`链接访问过时,情况基本同上,只不过需要将`:link`换成`:visited`.
   - `:link`和`:visited`可以交换位置,因为一个`a`链接要么处于未访问状态,要么处于访问状态,他们并不冲突.
2. `hover` 伪类并不限用于 `a` 元素，它可以定义任何一个元素在鼠标经过时的样式。



### 相对于父元素的结构伪类

| 写法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| `E:first-child`       | 查找`E`这个元素的父元素的第一个子元素`E`，如果第一个子元素不是`E`类型，则查找无效 |
| `E:last-child`        | 查找`E`这个元素的父元素的最后一个子元素`E`，如果最后一个子元素不是`E`类型，则查找无效 |
| `E:nth-child(n)`      | 查找`E`这个元素的父元素的第`n`个子元素`E`（注意索引是从1开始的，第一个的索引就是1，不要下意识以为第一个的索引是0）<br />如果第`n`个子元素不是`E`类型，则查找无效；`n`也可以是关键字或表达式，见下 |
| `E:nth-last-child(n)` | 同`E:nth-child(n)` 相似，只是倒着计算                        |
| `E:nth-child(even)`   | 此处`n`就是取关键字`even`，表示偶数项的元素                  |
| `E:nth-child(odd)`    | 此处`n`就是取关键字`odd`，表示奇数项的元素                   |
| `E:empty`             | 选中没有任何子节点的`E`元素，注意，空格也算子元素            |
| `E:target`            | 结合锚点进行使用，处于当前锚点的元素会被选中                 |


上面有关`child`的选择器我们可以发现到一个很大的缺点，就是在查找的过程中并没有将元素类型限制成我们想要查找的`E`类型，一旦按照索引查找到的元素不是`E`类型的元素，则查找无效，这在变化多端的动态数据中是极其容易出现的。因此，`CSS3`又提供了更为实用的选择器：

| 写法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| `E:first-of-type`  | 查找`E`元素的父元素的第一个`E`类型的元素，查找的时候只会查找满足`E`类型的元素，过滤掉其它类型的元素 |
| `E:last-of-type`   | 查找`E`元素的父元素的最后一个`E`类型的元素，查找的时候只会查找满足`E`类型的元素，过滤掉其它类型的元素 |
| `E:nth-of-type(n)` | 查找`E`元素的父元素的第`n`个`E`类型的元素，查找的时候只会查找满足`E`类型的元素，过滤掉其它类型的元素 |

需要重点说明的是关于 `nth-child(n)` 和 `nth-of-type(n) `中的`n`，它遵循线性变化，取值范围为0~查找元素的长度。但是当 `n≤0`时，选取是无效的。如当 `n` 是一个表达式，`nth-of-type(-n+5)` 表示查找 `nth-of-type(5)、nth-of-type(4)、nth-of-type(3)、nth-of-type(2)、nth-of-type(1)`，即查找前五个子元素 。

## 伪元素选择器

> 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过`:before`来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：`::before`，`::after`，`::first-line`，`::first-letter`，`::selection`、`::placeholder`等

> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素

| 例子              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| `E::before`       | 定义在一个元素之前插入 `content `属性定义的内容和样式        |
| `E::after`        | 定义在一个元素之前插入 `content` 属性定义的内容和样式        |
| `E::first-letter` | 文本的第一个字母或字(不是词组)                               |
| `E::first-line`   | 文本第一行；如果设置了`::first-lette`，那么无法同时设置`::first-line`的样式 |
| `E::selection`    | 可改变选中文本的样式；它只能设置显示的样式，而不能设置内容大小 |

`E::before、E::after`：分别定义在一个元素之前和之后插入 `content` 属性定义的内容和样式。注意：

1. 是一个行内元素，需要通过以下三种方法转换成块元素：`float、display:block、position`（常用）；

2. 必须添加 `content:""`，就算不设置内容；

3. 在`CSS2`中是伪类——`E:before、E:after`，在`CSS3`中是伪元素——`E::before、E::after`。在新版本下，`E:after、E:before`会被自动识别为`E::after、E::before`。有时为了兼容处理，还是会写成`E:after、E:before`。



## 浏览器是如何解析`css`选择器的

样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。

采用这种解析方式的原因是:

- `HTML` 经过解析生成` DOM Tree`；而在 `CSS` 解析完毕后，需要将解析的结果与 `DOM Tree` 的内容一起进行分析建立一棵 `Render Tree`，最终用来进行绘图。`Render Tree` 中的元素（`WebKit` 中称为`renderers`，`Firefox` 下为`frames`）与 `DOM `元素相对应，但非一一对应：一个 `DOM` 元素可能会对应多个 `renderer`，如文本折行后，不同的「行」会成为 `render tree` 种不同的 `rendere`r。也有的 `DOM` 元素被` Render Tree` 完全无视，比如 `display:none` 的元素。
- 在建立` Render Tree` 时（`WebKit`中的`Attachment`过程），浏览器就要为每个 `DOM Tree` 中的元素根据 `CSS` 的解析结果（`Style Rules`）来确定生成怎样的` renderer`。对于每个 `DOM` 元素，必须在所有 `Style Rules` 中找到符合的 `selector` 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 `DOM Tree` 时，从 `Style Rules` 中去寻找对应的 `selector`。
- 因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 `DOM` 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个` selector` 不匹配当前元素」就是极其重要的。
- 如果正向解析，例如「`div div p em`」，我们首先就要检查当前元素到 `html` 的整条路径，找到最上层的 div，再往下遍历，如果遇到不匹配的就需要回溯到顶层,如此回溯若干次才能找到确切的`dom`;
- 逆向匹配则不同，如果当前的 `DOM` 元素是 div，而不是 `selector` 最后的 `em`，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。
- 因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。