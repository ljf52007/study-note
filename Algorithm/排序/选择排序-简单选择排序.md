简单选择排序的核心思想是不断地找出未排序数列的最小值,将其添加到有序数列的尾部.(当然也可以选择最大值)

## 算法过程

```
(从小到大排序)
1. 在待排数列中找到最小(或最大)元素,存放于有序数列的起始位置;
2. 从余下待排数列中找到最小(或最大)元素,存放于有序数列的末尾(或开头);
3. 重复第二步,直到所有元素排序完毕.
```



## 排序演示

对下面的数列进行简单选择排序

```
5, 3, 2, 4, 1
```

设置两个指针,指针`a`指向待排数列起始位,指针`b`指向待排数列末位.

```
5, 3, 2, 4, 1
↑a          ↑b
```

遍历待排数列`[5, 3, 2, 4, 1]`,找到最小值`1`,将其与指针`a`所指项交换,指针`1`右移一位

```
1, 3, 2, 4, 5
   ↑a       ↑b
```

遍历待排数列`[3, 2, 4, 5]`,找到最小值`2`,将其与指针`a`所指项交换,指针`a`右移一位

```
1, 2, 3, 4, 5
      ↑a    ↑b
```

遍历待排数列`[3, 4, 5]`,找到最小值`3`,`3`即为指针`a`所指项,无需交换,指针`a`右移一位

以此类推,得到排序结果

```
1, 2, 3, 4, 5
```



## 代码实现

```js
const arr = [3, 4, 6, 11, 9, 5, 7, 8, 1, 2, 10];

// 交换方法
function swap(arr, i ,j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

// 简单选择排序函数
function selectSort(arr) {
  // 缓存数组长度
  let len = arr.length;
  let minIndex;
  // 外层循环 i表示当前待排序列的起点,也就是前面的指针a
  for (let i = 0; i < len - 1; i++) {
    // 初始化最小值索引为当前待排序列的首项索引
    minIndex = i;
    // 内层循环 遍历待排数列 选出最小值
    for (let j = i + 1; j < len; j++) {
      // 选出最小值索引
      if (arr[j] <= arr[minIndex]) minIndex = j;
    }
    // 交换最小值与指针a所指项
    swap(arr, i, minIndex);
  }
  return arr;
}
```



## 时间复杂度

简单选择排序无论什么情况下,都要走内外两层循环,因此时间复杂度为`O(n^2)`.



## 稳定性

简单选择排序是不稳定的,举个例子,序列`5 8 5* 2 9`,我们知道第一遍选择第一个元素`5`会和`2`交换.从而导致`5`在`5*`的后面.