直接插入排序的核心思想是,待排数列一个一个地插入有序数列,不断扩大有序数列,直到待排数列为空.

## 算法过程

```
(从小到大排序)
1. 单个数字一定有序,因此数组首项可以看做一个有序数列,剩余的项组成待排数列;
2. 从头到尾依次扫描待排数列,将扫描到的每个元素插入有序数列的适当位置.(如果待插入的元素与有序数列中的某个元素相等,则将待插入元素插入到相等元素的后面)
```



## 排序演示

对下面数列进行直接插入排序:

```
5, 3, 2, 4, 1
```

将数列首项`5`作为有序数列,待排数列为`[3,2,4,1]`,取待排数列首项`3`作为当前元素,与有序数列`[5]`从后往前进行比较

```
5, 3, 2, 4, 1
↑  ↑
```

`3`小于`5`,`5`向后移一位,腾出位置给`3`,此时有序数列为`[3, 5]`,待排数列为`[2, 4, 1]`

```
3, 5, 2, 4, 1
```

取待排数列首项`2`作为当前元素,与有序数列`[3, 5]`从后往前进行比较

```
3, 5, 2, 4, 1
   ↑  ↑
```

`2`小于`5`,`5`向后移一位,腾出空位.`2`继续往前,与`3`作比较

```
3, 空位, 5, 4, 1
↑  当前元素2
```

`2`小于`3`,`3`向后移一位,腾出位置给`2`,此时有序数列为`[2, 3, 5]`,待排数列为`[4, 1]`

取待排数列首项`4`作为当前元素,与有序数列`[2, 3, 5]`从后往前进行比较

```
2, 3, 5, 4, 1
      ↑  ↑
```

`4`小于`5`,`5`向后移一位,腾出空位.`4`继续往前,与`3`作比较

```
2, 3, 空位, 5, 1
   ↑  当前元素4
```

`4`不小于`3`,当前元素`4`填入空位.此时有序数列为`[2, 3, 4, 5]`,待排数列为`[1]`

以此类推,最后一个元素`1`会插入到有序数列的,最终得到的有序数列`[1, 2, 3, 4, 5]`即为排序完成的结果.



## 代码实现

```js
const arr = [5, 3, 2, 4, 1, 7, 10, 9, 8, 6]
function insertSort(arr) {
    // 缓存数组长度
    let len = arr.length,
        curValue;
    // 外层循环,遍历待排数列
    for (let i = 1; i < arr.length; i++) {
        // curValue 待排数列的当前元素
        curValue = arr[i];
        // 内层循环,从后往前遍历有序数列
        for (let j = i - 1; j >= 0; j--) {
            // curValue小于有序数列当前值,则有序数列当前值后移一位,curValue插入
            if (curValue < arr[j]) {
                arr[j + 1] = arr[j];
                arr[j] = curValue;
            } else {
			   // 如果curValue不小于有序数列当前值,则不再往后比较,直接将curValue插入当前位置
                break;
            }
        }
    }
    return arr;
}

```



## 时间复杂度

- 最好情况下:原数列有序,此时内层循环只走一次,整体复杂度取决于外层循环,时间复杂度是`O(n)`.
- 最坏情况下:原数列逆序,此时内层循环每次都要比较和移动有序数列里所有的元素,时间复杂度是两层循环的`O(n^2)`;
- 平均时间复杂度:`O(n^2)`.



## 稳定性

从插入排序的排序过程分析,从未排序数列取首项,与有序数列从后往前比较时,如果两个元素相等,则有序数列的值不腾出位置.两个元素的先后位置并未改变,因此插入排序是稳定的.