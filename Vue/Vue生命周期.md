## 生命周期流程图

![](https://gitee.com/ljf52007/note/raw/master/images/Vue/lifecycle.png)



## 生命周期调用时机

| 生命周期钩子      | 调用时机                                                     |
| ----------------- | ------------------------------------------------------------ |
| `beforeCreate()`  | 在实例初始化之后,数据观测`(data observer)`之前调用           |
| `created()`       | 实例已经创建完成之后被调用.<br />在这一步,实例已经完成以下的配置:<br />数据观测`(data observer)`,属性和方法的运算,`watch/event`事件回调.<br />需要注意的是,此时拿不到`$el` |
| `beforeMount()`   | 在挂载开始之前被调用:<br />相关的`render`函数首次能被调用    |
| `mounted()`       | `el`被新创建的`vm.$el`替换,并挂载到实例上后调用              |
| `beforeUpdate()`  | 数据更新前调用,发生在虚拟`DOM`重新渲染和打补丁之前           |
| `updated()`       | 数据变化导致虚拟`DOM`重新渲染和打补丁,在这之后调用该钩子     |
| `beforeDestroy()` | 实例销毁之前调用,在这一步,实例仍然完全可用                   |
| `destroyed()`     | `Vue`实例销毁后调用.<br />调用后,`Vue`实例指示的所有东西都会解除绑定,所有的事件监听器会被移除,所有的子实例也会被销毁.<br />该钩子在服务器端渲染期间不被调用. |



## 每个生命周期内部可以做什么事

- `created()`

  实例已经创建完成,可以进行一些数据,资源的请求.(如`Ajax`请求)

- `mounted`

  实例已经挂载完成,可以进行一些数据,资源的请求,还可以进行一些`DOM`操作

- `beforeUpdate()`

  可以在这个钩子中进一步地更改状态,因为此时还未更新,所以更改状态不会触发附加的重渲染过程

- `updated()`

  可以执行依赖于`DOM`的操作.

  大多数情况下,应该避免在这个钩子中更改状态,因为这可能会导致更新无限循环.

  该钩子在服务器端`(ssr)`渲染期间不被调用.

- `beforeDestroy()`和`destroyed()`

  可以执行一些优化操作,清空定时器,解除绑定事件等.

  

> `ajax`请求放在哪个生命周期中?
>
> 可以在`created`或`mounted`钩子中进行`ajax`请求.但是,在`created`的时候,视图中的`dom`还未渲染,因此此时无法操作`dom`元素;
>
> 一般来说,可以把请求都放到`mounted`中,保证逻辑的统一性,因为生命周期是同步执行的,`ajax`是异步执行的,`ajax`请求并不会阻塞到生命周期钩子的调用.(换句话说,一般情况下,能放在`created`的异步请求,都能放到`mounted`中.)
>
> 注意,服务器端渲染不支持`mounted`方法,因此在服务器端渲染的情况下统一将请求放到`created`.



> 什么时候需要用到`beforeDestroy`?
>
> - 如果在当前页面使用了`$on`方法,需要在组件销毁前将其解绑;
> - 清除自己定义的定时器;
> - 解除事件的绑定,如`scroll`等;
