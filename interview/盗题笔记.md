如果每道题都能精雕细琢,完全吃透,面试的时候不敷衍,不潦草,回答出让面试官满意的答案,那你在面试这关,基本无敌.

# `HTML`

### `Html5`语义化的理解

1. 语义化的背景:

   以前的`HTML`的结构,基本上就是`div+css`,然而,`div`并没有什么实际意义,全靠`css`显示页面的样式.后来,开发者提出了`HTML`结构的语义化,`w3c`也制定出了语义化标签.

2. 什么是语义化:

   语义化就是构成`HTML`结构的标签要有意义,比如有这样的标签:`head`表示头部,`main`表示内容主体,`footer`表示页面底部.那么这些标签构成的`HTML`结构就是语义化的.如果头部,主体,底部都用`div`来表示,那么他就不是一个语义化的`HTML`结构了.

3. 怎么知道页面结构是否语义化?

   可以去掉`css`,看`html`代码的结构是否清晰,再看页面内容呈现是否便于阅读;

4. 为什么要语义化?

   - 对于开发者来说,更加容易开发,阅读与维护;
   - 对于爬虫,搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重,有利于`SEO`;
   - 对于浏览器来说,语义化的`html`结构更加清晰,更加方便解析;
   - 对于用户,能提供更好的用户体验——一是假如`css`加载失败,页面也能呈现出良好的结构,二是某些标签如`label`和有些标签属性如`alt`,`title`能带来良好的用户体验;三是在特殊终端如视障阅读器中语义化的`HTML`可以呈现良好的结构.

5. 如何做到语义化?

   - 用正确的标签做正确的事情,如尽量不使用样式标签`b,font`;强调文本放在`strong,em`中,不使用`b,i`等;使用表格`table`时,标题用`caption`,表头用`thead`,主体用`tbody`,尾部用`tfoot`,表头节点用`th`,单元格用`td`;`input`标签通过`id`属性或`for`属性与`label`标签关联等等;
   - `html`语义化,`css`类名也要语义化;
   - `html5`新增了一些语义化标签,如`header,footer,nav,aside,article`等等;



# `JS`

### `JS`为什么单线程,有什么办法多线程吗?



### 原型链

### 闭包

### `new`对象

### 继承

### `ts`的特点,有什么缺点,与`js`对比

### `Node`和`JS`事件循环对比

### 对`Node`有什么了解?

### 浅拷贝和深拷贝

### 深拷贝边界问题

### `async`和`defer`

### `es6`用过什么?

### 说下`let const`

### `es6`扩展运算符可以解决哪些问题?

### 说下`promise`,手写

### `promise`的缺点是什么

### 跨域

### `canvas`相关,它有跨域问题吗

### 事件循环

### 事件流

### 数组方法

### `js`去重的方法

### 判断是否为数组的方法？优缺？

1. 不能用typeof，typeof只能判断数组为object，不能明确为Array

2. 不能用.length，因为其他诸如函数也有length属性

3. instanceof，可以判断，instanceof是通过原型链去判断数据类型的，但是存在框架问题（如果从一个框架传一个数组到另一个框架，instanceof可能会找不到构造函数）

4. Array.isArray()，可以判断，老版本的浏览器不支持

5. Object.prototype.toString.call()

   ```js
   var arr = [];
   Object.prototype.toString.call(arr) == "[object Array]"; // true
   ```

   

### `window`有哪些对象？

主对象主要有：`document`对象，`frames`对象，`history`对象，`location`对象，`navigator`对象，`screen`对象

# `CSS`

### `css`盒模型

### 一个弹窗实现居中布局怎么做

### 实现元素垂直上下居中的方法

### `flex: 1`表示什么

### `BFC`,`IFC`



# 浏览器

### 浏览器缓存

### 浏览器存储,`cookie`,`localStorage`,`sessionStorage`,`indexdb`

### 浏览器输入`URL`发生了什么

### 浏览器页面渲染流程

#### 渲染流程

> 浏览器渲染流程是什么?

渲染的过程其实就是将`url`对应的各种资源, 通过浏览器渲染引擎的解析,输出可视化的图像:

```
HTML/CSS/JavaScript => 浏览器渲染引擎 => 图像
```

1. 浏览器解析`HTML`文件为`DOM`树

   当我们打开一个网页,浏览器请求对应的`HTML`(在网络传输中是0和1的字节数据),将这些字节数据转换为字符串(我们写的代码).

   接着再将字符串通过词法分析转换为标记(`token`),这一过程在词法分析中称为标记化(`tokenization`).

   ```
   那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思
   ```

   结束标记后,这些标记会紧接着被转换为`Node`,最后根据这些`Node`之间的联系,构建`DOM`树.

   ```
   字节数据 => 字符串 => token => Node => DOM树
   ```

2. 将`CSS`文件转换为`CSSOM`树(`CSS`对象模型树)

   这一过程与构建`DOM`树是相似的.

   ```
   字节数据 => 字符串 => token => Node => CSSOM树
   ```

   在这一个过程中,浏览器会确认每一个节点的样式是什么,并且这个过程是很消耗资源的(样式的设置是多样化的).因此,我们应该尽可能的避免写过于具体的`CSS`选择器,如`div > a > span`,然后对于`HTML`来说,也尽量少的添加无意义标签,保证层级扁平.

   根据页面渲染流程可得知:

   - `css`加载不会阻塞`DOM`树的解析,但会阻塞`DOM`树的渲染;
   - `css`加载会阻塞后面`js`语句的执行

   

3. 生成`Render Tree`(渲染树)

   生成`DOM`树和`CSSOM`树后,就会将这两颗树组合为渲染树.

   ```
   这一过程并不是简单的合并,`render tree`只会包括需要显示的节点和这些节点的样式信息,比如,如果某个节点的样式是`display:none`,就不会在`render tree`中显示.
   ```

4. 浏览器生成`render tree`后,就会根据`render tree`来进行布局(也叫回流或者重排),然后调用`GPU`绘制,合成图层,显示在屏幕上.

#### 阻塞渲染

> 什么情况会阻塞渲染?怎么解决?

| 阻塞                                                         | 解决                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 渲染的前提首先是生成渲染树,因此`HTML`和`CSS`的解析肯定会阻塞渲染 | 应该从一开始降低需要渲染的文件大小,比如`HTML`保证层级扁平,`CSS`优化选择器 |
| 浏览器解析到`script`标签时,会暂停`DOM`的构建.解析完`js`后才会从暂停的地方重新开始构建 | 不应该在首屏加载`js`文件,将`script`标签至于`body`底部(当然,也可以添加`defer`和`async`属性)<br />`defer`属性表示该`js`文件会并行下载,但是会放到`HTML`解析完成后执行.<br />对于没有任何依赖的`js`文件可以添加`async`属性,表示`js`文件的下载和解析不会阻塞渲染. |



#### 重绘&回流

- 重绘(`repaint`): 当渲染树中的元素外观(如:`color`)发生改变,不影响布局时,产生重绘;
- 回流(`reflow`): 当渲染树中的元素布局(如:尺寸,位置,隐藏状态)发生改变时,产生回流(重排);
- 当`JS`获取`Layout`的属性值(如:`offsetLeft,scrollTop,getComputedStyle`等),也会引起回流,因为浏览器需要通过回流重新计算最新的值;
- 回流必将引起重绘,而重绘不一定会引起回流;

> 如何针对重绘和回流进行前端优化?

1. 需要对元素进行复杂的操作时,可以先隐藏 该元素(`display:none`),操作完成以后,再显示;
2. 需要创建多个`DOM`节点时,使用`DocumentFragment`创建完后一次性地加入`document`;
3. 缓存`Layout`的属性值,如:`let left = elem.offsetLeft`,这样多次使用`left`只产生第一次的回流;
4. 尽量避免使用`table`布局,`table`元素一旦触发回流就会导致`table`里所有的其他元素回流;
5. 尽量避免`css`表达式(`expression`),因为每次调用都会重新计算值(包括加载页面);
6. 尽量使用`css`属性的简写,如用`border`代替`border-width,border-style,border-color`;
7. `JS`中批量修改元素的样式,如:`elem.className`和`elem.style.cssText`代替`elem.style.xxx`;



#### `DOM`操作

>操作`DOM`性能为什么会变差?

1. `DOM`属于渲染引擎,`JS`属于`JS`引擎,通过`JS`操作`DOM`涉及了两个线程之间的通信,势必会带来一些性能的损耗.操作`DOM`的次数一多,就等同于一直在进行线程之间的通信.
2. 操作`DOM`可能会带来重绘和回流的情况.

> 经典面试题:插入几万个`DOM`,怎么实现页面不卡顿?

首先,不可能把几万个`DOM`一次性插入,这样做是绝对会卡顿的,解决问题的关键应该从减少`DOM操作次数`和`缩短循环时间`两个方面去减少主线程阻塞的时间.

1. `DocumentFragment`

   减少`DOM`操作次数的良方是`createDocumentFragment API`,它用来创建一个虚拟的节点对象,或者说,是用来创建文档碎片节点.`DocumentFragment`节点不属于文档树,继承的`parentNode`属性总是`null`.

   `DocumentFragment`有一个很实用的特点,当请求把一个`DocumentFragment`节点插入文档树时,插入的不是`DocumentFragment`自身,而是它的所有子孙节点.这使得它起到了一个暂存节点的作用.因此,当需要添加多个`dom`元素时,如果先将这些元素添加到`DocumentFragment`中,再统一将`DocumentFragment`添加到`DOM`树种的节点,可以减少页面渲染`DOM`的次数,效率明显提升.

   以下是原生插入3万个节点和利用`DocumentFragment`插入3万个节点的对比:

   ```js
   // 原生插入
   console.time('原生插入耗时')
   
   const list = document.getElementById('ul');
   let insertCount = 30000; // 插入的节点数
   let count = 0; // 当前已插入的节点数
   function protoRender() {
     while (count <= insertCount) {
       const li = document.createElement('li');
       li.innerHTML = `原生插入节点${count}`;
       list.appendChild(li);
       count++;
     }
   }
   protoRender();
   
   console.timeEnd('原生插入耗时'); // 原生插入耗时: 154.080322265625 ms
   ```

   ```js
   // DocumentFragment 插入
   console.time('DocumentFragment插入耗时')
   
   const list = document.getElementById('ul');
   let insertCount = 30000;
   let count = 0;
   function fragmentRender() {
     const fragment = document.createDocumentFragment();
     while (count <= insertCount) {
       const li = document.createElement('li');
       li.innerHTML = `DocumentFragment记录${count}`;
       fragment.appendChild(li);
       count++;
     }
     if (count > insertCount) {
       list.appendChild(fragment);
     }
   }
   fragmentRender();
   
   console.timeEnd('DocumentFragment插入耗时'); // DocumentFragment插入耗时: 151.240234375 ms
   ```

2. 通过`requestAnimationFrame`(`rAF`)的方式循环插入`DOM`

   现代浏览器提供了`requestAnimationFrame``API`来解决非常耗时的代码段对渲染的阻塞问题.,`DocumentFragment`可以减少`DOM`操作次数,`requestAnimationFrame`可以保证新节点操作在页面重绘前执行,二者结合可以实现数据渲染优化.

   ```js
   // DocumentFragment && requestAnimationFrame
   console.time('rAF插入耗时');
   
   const list = document.getElementById('ul');
   const total = 30000; // 需要插入的节点数
   const insertCount = 51; // 一次插入的节点数
   const insertTimes = Math.ceil(total / insertCount); // 需要处理的批次数
   let finishCount = 0; // 已经插入的批次数
   function fragmentRender() {
     const fragment = document.createDocumentFragment();
     const count = total - (finishCount * insertCount); // 未插入的节点数
     const forCount = count >= insertCount ? insertCount : count; // 需要遍历的节点数
     for (let i = 0; i < forCount; i++) {
       const li = document.createElement('li');
       li.innerHTML = `rAF记录${finishCount * insertCount + i + 1}`;
       fragment.appendChild(li);
     }
     list.appendChild(fragment);
     finishCount++;
     rAfRender();
   }
   
   function rAfRender() {
     if (finishCount < insertTimes) {
       window.requestAnimationFrame(fragmentRender);
     }
   }
   rAfRender();
   
   console.timeEnd('rAF插入耗时'); // rAF插入耗时: 0.15771484375 ms
   ```

3. 虚拟滚动`virtualized scroller`,这种技术的原理就是只渲染可视区域内的内容,非可见区域的就完全不渲染.当用户滚动的时候,实时替换渲染的内容.



# `Vue`

### 父子组件如何通信?非父子组件如何通信?

### 组件传参

### 父组件向子组件传入动态的值怎么处理?

### 为啥拿`vuex`的数据你用`getter`去拿,不用`state`

### 说下`vuex`,`vuex`的数据什么时候消失?怎么实现持久存储?

### 存储`token`的过程说一下

### `axios`的使用

### `vue`使用`axios`怎么终止请求,实现原理是什么

### `keep-alive`的应用场景,及相关的生命周期

### `Angular`和`Vue`对比,优缺点,为什么公司用`angular`?

### `Angular`和`Vue`的生命周期

### `vue`生命周期`dom`什么时候可以操作

### `created`有什么方法可以实现`dom`操作吗

### `vue`路由钩子

### 权限问题,权限的实现方式

### `vue`响应式原理

### `vue`响应式原理,为什么检测不到数组长度变化

### `vue3`的了解程度

### `vue2`和`vue3`双向绑定的差异

### nextTick的存在意义是什么？

因为vue是异步更新Dom的，一旦观察到数据更新呢，就会开开一个队列，然后把当前事件循环中观察到的watcher加入到这个队列，即便watcher触发多次，也推送一次，而在下一个事件循环开始，vue进行必要的dom操作，并且清空队列，而nextTick是在dom更新后和队列清空后额外加入的一个操作。

### `nexttick`源码

### `vue`与`react`的`hook`有什么区别

### 路由参数两种模式的区别

### 路由`history`模式怎么监听变化,`hash`模式的缺点

### `v-for`中的`key`

### `v-for`和`v-if`为什么不建议一起用

### 组件异步加载

### 路由懒加载

### 为什么`data`是一个返回对象的函数

### `computed`和`watch`区别(缓存,异步)

### 虚拟`dom`和`diff`

### 使用第三方组件(如`element-ui,iview`),如何实现样式的覆盖?

### `vue`中轮播图组件的开发流程(简略代码实现,页面布局,功能)

### 列出至少4种`vue`当中的指令和它的用法,如何自定义`vue`指令

### `vue-router`中`$router`与`$route`的区别

### `vue`事件总线



# HTTP

### `Web`安全,预防措施

### 说说常见的请求头和响应码,301和302的区别是什么

### `tcp`三次握手具体过程

### `http`缓存你了解多少

### `get`和`post`的相同点和不同点

# `Webpack`

### `Webpack`配置过吗?用`webpack`怎么配置来优化,用过代理吗?

### `webpack`由哪几个组成?

### `loader`和`plugin`差别

### 如何打包分成多个`js`

### 如何配置多个`index.html`(多页面应用)[输出传数组]

### 常用的`plugin`

### 摇树优化





# 手写 

### 手写防抖

```js
function debounce(fn, wait = 500) {
  // 初始化一个计时器
  let timer = 0;
  return function(...arg) {
   	// 将已存在的计时器删除，并重新定义一个新的计时器
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      // apply指定this指向
      fn.apply(this, arg);
    }, wait)
  }
}
```



### 手写节流

```js
function throttle(fn, wait = 500) {
  // 初始化lastTime
  let lastTime = 0;
  return function(...arg) {
    // 保存当前操作的时间
    let now = +new Date();
    if (now - lastTime > wait) {
      // 如果当前操作时间和lastTime的差值大于设定的等待时间，则执行函数
      fn.apply(this, arg);
      // 将当前时间赋值给lastTime，为下一次操作做准备
      lastTime = now;
    }
  }
}
```



### 手写深拷贝

（解决循环引用问题，未解决函数类型深拷贝，以及不可遍历的特殊类型深拷贝）

```js
// 深拷贝
function deepCopy(oldObj, map = new Map()) {
  // 如果已经拷贝过，直接return，解决循环引用问题
  if (map.get(oldObj)) return oldObj;
  // 如果是值类型或null（这里没有考虑到函数function类型）
  if (typeof oldObj !== 'object' ||  oldObj === null) return oldObj;
  // map保存键值对
  map.set(oldObj, true);
  let newObj = Array.isArray(oldObj) ? [] : {};
  for (const key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      // 递归拷贝
      newObj[key] = deepCopy(oldObj[key], map);
    }
  }
  return newObj;
}


const deepCopy = function (target, cache = []) {
  for (let i = 0; i < cache.length; i++) {
    if (cache[i].target === target) {
      return cache[i].result;
    }
  }

  const type = Object.prototype.toString.call(target).slice(8, -1);
  let result = null;
  if (['String', 'Number', 'Boolen', 'Undefined', 'Null', 'Symbol', 'BigInt'].includes(type)){
    return target;
  } else if (type === 'Object'){
    result = {};
  } else if (type === 'Array') {
    result = [];
  } else if (type === 'Date') {
    result = new Date(target);
  } else if (type === 'RegExp') {
    result = new RegExp(target.source, target.flags);
  } else if (type === 'Function') {
    result = target.bind(this);
  } 

  cache.push({target, result});

  for (const key in target) {
    if (target.hasOwnProperty(key)) {
      result[key] = deepCopy(target[key], cache);
    }
  }
  return result;
}

export default deepCopy;
```



### 手写Event Bus

```js
class EventEmeitter {
  constructor() {
    // map类型存储type-fn键值对
    this._events = this._events || new Map();
    this.maxListeners = this.maxListeners || 10;
  }

  // 监听名为type的事件
  addListener(type, fn) {
    const handler = this._events.get(type);
    if (!handler) {
      // 如果handler不存在，则说明该类型事件未监听
      this._events.set(type, fn);
    } else if (handler && typeof handler === 'function') {
      // handler存在且handler是函数，说明只有一个监听者
      this._events.set(type, [handler, fn]); // 多个监听者需要用数组存储
    } else {
      // handler本身是数组
      handler.push(fn);
    }
  }

  removeListener(type, fn) {
    const handler = this._events.get(type);
    if (handler && typeof handler === 'function') {
      // 如果handler是函数，说明只有一个监听者，直接删
      this._events.delete(type, fn);
    } else if (Array.isArray(handler)) {
      // handler是数组，则需要遍历数组，找到对应的函数删除
      let position = -1;
      for (let i = 0; i < handler.length; i++) {
        if (handler[i] === fn) position = i;
        break;
      }
      if (position !== -1) {
        // 删除对应的fn
        handler.splice(position, 1);
        // 如果清除后只有一个函数,那么取消数组,以函数形式保存
        if (handler.length === 1) {
          this._events.set(type, handler[0]);
        }
      } else {
        return this;
      }
    }
  }

  emit(type, ...args) {
    let handler = this._event.get(type);
    // 如果没有handler，说明没有监听type事件，直接返回false
    if (!handler) return false;
    // 如果handler是一个数组，需要遍历数组依次调用
    if (Array.isArray(handler)) {  
      for (let i = 0; i < handler.length; i++) {
        if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
      }
    } else {
      if (args.length > 0) {
        handler.apply(this, args);
      } else {
        handler.call(this);
      }
    }
    return true;
  }
}
```



### 手写instanceof

```js
function MyInstance(instanceObj, func) {
  // 获取实例instanceObj的__proto__
  let protoObj = Object.getPrototypeOf(instanceObj);
  while (true) {
    // 沿着原型链查不到__proto__，说明已经查到了原型链顶端，此时还找不到当前类，返回false
    if (protoObj === null) return false;
    // 在当前实例对象的原型链上，找到了当前类
    if (protoObj === func.prototype) return true;
    // 沿着原型链__proto__一层一层向上查
    protoObj = Object.getPrototypeOf(protoObj);
  }
}
```



### 手写new

```js
function MyNew(fn, ...args) {
  // 创建一个对象（实例），且该对象__proto__指向F的prototype
  let instance = Object.create(fn.prototype);
  // 改变this的指向
  let res = fn.apply(instance, args);
  // 确保返回的结果是一个对象（万一fn不是构造函数）
  return typeof res === 'object' ? res : instance;
}
```



### 手写Object.create()

```js
// 该方法创建一个对象，且该对象的__proto__指向传入的参数proto
Object.prototype.myCreate = (proto) => {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



### 手写call

```js
Function.prototype.myCall =  function(context = window, ...args) {
  // 如果非函数调用myCall，抛出错误
  if (typeof this !== 'function') {
    throw new Error('Not function!');
  }
  // 使用Symbol定义唯一的属性
  let key = Symbol('fn');
  context[key] = this;
  let res = context[key](...args);
  // 删除context[key]释放内存，否则context的属性会越来越多
  delete context[key];
  return res;
}
```

手写apply与手写call是一样的，只需要修改传入参数的方式：

```js
let res = context[key](args);
```



### 手写bind

```js
Function.prototype.myBind = function(context = window, ...outerArgs) {
  // 非函数调用，报错
  if (typeof this !== 'function') {
    throw new Error('Not a function!');
  }
  // 保存this
  let self = this;
  return function F(...innerArgs) {
    // 如果是new的方式，这里的this与self已经不是同一个概念了
    if (this instanceof F) {
      return new self(...outerArgs, ...innerArgs);
    }
    return self.call(context, ...outerArgs, ...innerArgs);
  }
}

let obj = {
  name: 'lujiafeng'
};
function a(name, age) {
  this.name = name;
  this.age = age;
}
const fn = a.bind(obj, 'lilinqi', 18);
const ins = new fn();
console.log(ins);
console.log(obj);
```



### 判断类型

```js
let class2type = {};
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
	if (obj == null) return String(obj);
	return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj;
}
```



### `JS`实现多行省略(不重要)

```html
<div class="box">
  <p class="p" rows='3'>这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字</p>
</div>

<script>
  // 获取需要设置多行省略的标签
  const elBoxs = document.getElementsByClassName('p');
  const elBoxsLength = elBoxs.length;

  // 没有使用forEach(有些浏览器不兼容)和map（标签数组不能使用map的方法）
  for(let i = 0; i < elBoxsLength; i += 1) {
    const el = elBoxs[i];
    let text = el.innerHTML;
    // 需要在第几行省略，是否支持webkitLineClamp属性
    let options = {
      rows: parseInt(el.getAttribute('rows')),
      isSupportlineCamp: `${el.style.webkitLineClamp}` !== 'undefined',
    };

    // 设置需要省略的属性及字体的两端对齐的样式
    el.style.overflow = 'hidden';
    el.style.textOverflow = 'ellipsis';
    el.style.wordBreak = 'break-all';
    el.style.wordWrap = 'break-word';
    el.style.textAlign = 'justify';

    // 支持webkitLineClamp的话直接使用浏览器css样式设置省略号（safari不是很支持，可以直接使用js计算方式），否则通过计算方式
    if(options.isSupportlineCamp) {
      el.style.webkitLineClamp = options.rows;
      el.style.display = '-webkit-box';
      el.style.webkitBoxOrient = 'vertical';
    } else {
      const heightStr = getCurrentStyle(el, 'height');
      const height = getNumber(heightStr);
      const maxHeight = getMaxHeight(el, options.rows, text);
      if(height > maxHeight) {
        subStrChar(el, maxHeight, text);
      } else {
        el.innerHTML = text;
      }
    }
  };

  // 截取字符串，从第一个开始，当前高度大于最大高度时，截取到前一个字符；
  function subStrChar(el, maxHeight, text) {
    console.log(maxHeight);
    let end = false;
    let i = 0;
    while(!end) {
      i++;
      el.innerHTML = text.substring(0, i) + '...';
      const currentHeightStr = getCurrentStyle(el, 'height');
      const currentHeight = getNumber(currentHeightStr);
      if(currentHeight > maxHeight) {
        el.innerHTML = text.substring(0, i - 1) + '...';
        end = true;
      }
      if(i >= text.length) {
        break;
      }
    }
  }

  // 获取最大高度，当line-height为normal的时候，对标签塞入字符，获取一行的行高
  function getMaxHeight(el, rows, text) {
    const lineHeight = getCurrentStyle(el, 'lineHeight');
    let number = 0;

    if(lineHeight === 'normal') {
      let index = 0;
      do {
        el.innerHTML = text[index++];
      } while(!getNumber(getCurrentStyle(el, 'height')));
      number = getNumber(getCurrentStyle(el, 'height'));
    } else {
      number = getNumber(lineHeight);
    }

    return number * rows;
  }

  // 获取当前元素的属性值
  function getCurrentStyle(el, elAttr) {
    // getComputedStyle获取元素的所有CSS属性的值
    return window.getComputedStyle(el)[elAttr]
  }

  // 将获取的字符串值变成向上取整成数字
  function getNumber(str) {
    let number = parseFloat(str);
    return Math.ceil(number)
  }
</script>
```



# 其他

### 登录状态保持实现流程,`jwt`了解吗

### `servicework`

### `token`过期处理

### 手机适配,移动端`1px`变粗

### 预处理器语法

### 性能优化

### 上传大文件优化和处理方式(分片上传,断点续传)

### `ios`图片旋转问题

### `flow-layout`

### 如何验证用户,设备的唯一性

### 网页死机,白屏怎么办

### 语义化版本控制

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

### 你在你的项目中遇到过什么兼容性处理?

1. 后端返回`2021-06-11`这样字符串日期,在安卓上使用`new Date`是正常可以获取时间格式的，但是在`ios`上使用`new Date`会报错，解决方案是把`-`转成`/`,即`new Date('2021/06-11')`;

2. 针对具有刘海屏或底部菜单横条的设备,进行兼容性处理,否则页面布局往往不符合需求

   ```css
   {html{--ion-safe-area-top:var(--ion-statusbar-padding)}}@supports (padding-top:constant(safe-area-inset-top)){html{--ion-safe-area-top:constant(safe-area-inset-top);--ion-safe-area-bottom:constant(safe-area-inset-bottom);--ion-safe-area-left:constant(safe-area-inset-left);--ion-safe-area-right:constant(safe-area-inset-right)}}@supports (padding-top:env(safe-area-inset-top)){html{--ion-safe-area-top:env(safe-area-inset-top);--ion-safe-area-bottom:env(safe-area-inset-bottom);--ion-safe-area-left:env(safe-area-inset-left);--ion-safe-area-right:env(safe-area-inset-right)}}
   ```

3. `ios`系统会将数字当成电话号码,因此会变色,解决方式是在`index.html`的`head`中添加:

   ```xml
   <meta name="format-detection" content="telephone=no"> 
   <meta http-equiv="x-rim-auto-match" content="none">
   ```

4. `input`框聚焦，`ios`会出现`outline`或者阴影，安卓显示正常,解决方式是

   ```css
   input:focus{outline:none}  //去除外边框
   input{-webkit-appearance: none;}
   ```

5. 

### 



# 一些题目

### 题1

样式：

```css
body{
    margin: 0;
    padding: 0;
}
div{
    height: 100px;
    width: 100px;
    left: 200px;
    top: 200px;
}
.div1{
    position: relative;
    background-color: red;
}
.div2{
    position: absolute;
    background-color: blue;
}
.div3{
    position: fixed;
    background-color: pink;
}
.div4{
    background-color: black;
}
```

dom:

```html
<div class="div1"></div>
<div class="div2"></div>
<div class="div3"></div>
<div class="div4"></div> 
```

问：四个div的展示效果是怎样的？

答：div1，2，3重叠，div4定位为static，因此`left`和`top`不起效，但是会被`position: relative`的div1挤下来

![图1](D:\front-end-note\images\面试题\图1.png)



### 题2

样式：

```css
.div1{
    height: 100px;
    width: 100px;
    background-color: red;
}
.div2{
    height: 10px;
    width: 10px;
    background-color: blue;
    margin-top: 50%;
    padding-top: 50%;
}
```

dom：

```html
<div class="div1">
    <div class="div2"></div>
</div>
```

问：界面是怎样的？

答：div2是div1的子级，`margin`和`padding`的百分比应该都是相对于父级的`width`和`height`

![图2](D:\front-end-note\images\面试题\图2.png)

### 题3

js：

```js
var name = 'a';
function outter(){
    var name = 'b';
    function inner(){
    console.log(name);
    console.log(this.name)
    }
    inner()
};
outter()
```

问：打印结果？

答：先b后a



### 题4

dom：

```html
<ul id="test">
    <li>这是第一条</li>
    <li>这是第二条</li>
    <li>这是第三条</li>
</ul>
```

问：点击每一li打印相应的index，请用非闭包，闭包以及事件委托三种方法实现

答：

1. 非闭包：用let

   ```js
   var liList = document.getElementById('test').children;
   for (let i = 0; i < liList.length; i++) {
       liList[i].onclick = function() {
           console.log(i)
       }
   }
   ```

   

2. 闭包：立即执行函数

   ```js
   var liList = document.getElementById('test').children;
   for (var i = 0; i < liList.length; i++) {
       liList[i].onclick = (function (index) {
           return function () {
               console.log(index)
           }
       })(i)
   }
   ```

   

3. e.target

   ```js
   var ulElement = document.querySelectorAll('#test')[0];
   ulElement.addEventListener('click', function(e) {
       if (e.target.nodeName !== 'LI') return;
       // 或 if (e.target.constructor !== HTMLElement) return; 
       var liArr = Array.from(ulElement.children);
       var index = liArr.indexOf(e.target);
       var content = liArr[index].innerHTML;
       console.log(index, content);
   }, false);
   ```

   





### 题5

问：有一个列表，上面有三个条件查询按钮ABC，每点一个按钮就会发送请求进行条件查询，请求时页面会有个`loading`，请求完毕后`loading`会消失。问，如果点了A以后，A尚未请求完就点B，此时应该如何控制`loading`？

答：第一种方法是变量或数组分别存储三个`loading`，分别控制三个查询；

第二种方法是全局定义一个`index = 0`，请求时`index+1`，请求完毕`index-1`，此时判断`index`是否为0，为0则`loading = false`。

第三种方法是请求中断？



### 题6

问：一个列表，里面记录的是任务，然后每一行都可以点击执行，但是这个执行很慢，所以这一行会转圈圈，然后你需要轮循向后端请求，执行完了没有，然后呢，又有一个执行所有的按钮，你点了之后就会执行所有的，而不是当前页的，而且你在第二页执行的loading状态，返回第一页，再返回去第二页，状态是保存的，问，怎么样设计轮训次数最少，后端可以根据你的设计来改。

答：查询当页咯，然后进行筛选，你要保存loading状态，执行完了就不loading



### 题7

问：看下面的代码，输出什么？

```JavaScript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

答：

```js
  Foo.getName(); // 2
  getName(); // 4
  Foo().getName(); // 1
  getName(); // 1
  new Foo.getName(); // 
  new Foo().getName(); // 
  new new Foo().getName(); // 
```

解析：

1. **Foo.getName();**

2. **getName();**

   `function`声明的函数会提升到代码的最前，因此4会将5覆盖，此时执行`getName()`即`window.getName()`，输出4

3. **Foo().getName();**

   `Foo()`执行，执行代码中`getName=function...`，实际上可分为两步，即`var getName;`和`getName=function...`。因此此时全局环境中的`getName`已经被1覆盖。

   `Foo()`的调用对象是`window`，因此`return this`即是`return window`

   因此，`Foo().getName()`即为`window.getName()`，输出1

4. **getName();**

   `getName()`相当于`window.getName()`，输出1

5. **new Foo.getName();**

   这里等价于`new (Foo.getName())`，先执行`Foo.getName()`，输出2，然后new一个实例。

6. **new Foo().getName();**

   这里等价于`(new Foo()).getName()`，先`new`一个`Foo`的实例，再执行这个实例的`getName`。但是这个实例本身没有这个方法，所以根据原型链查找规则，找到`Foo`的原型对象`prototype`上的`getName`方法。输出3

7. `new new Foo().getName();`

   这里等价于new `(new Foo().getName())`，如上述6，先输出3，然后`new`一个实例。

补充：

关于上述5中`new Foo.getName()`先执行`Foo.getName()`，而6中`new Foo().getName()`先执行`new Foo()`，是因为：

- `new Foo()`属于`new`（带参数列表）
- `new Foo`属于`new`（无参数列表）

无参数列表的优先级为18，而成员访问的优先级是19，高于无参数列表。因此`new Foo.getName()`先执行`Foo.getName()`

带参数列表的优先级为19，而成员访问的优先级也为19，按照运算符规则（同一优先级，按照从左到右的执行顺序），`new Foo().getName()`先执行`new Foo()`，再对`new`之后的实例进行成员访问`.getName()`操作。





### 题8

问：下面的代码输出什么？

```js
console.log("A");
setTimeout(() => console.log("B"), 1000);
const start = new Date();
while (new Date() - start < 3000) {}
console.log("C");
setTimeout(() => console.log("D"), 0);
new Promise((resolve, reject) => {
  console.log("E");
  foo.bar(100);
 })
.then(() => console.log("F"))
.then(() => console.log("G"))
.catch(() => console.log("H"));
console.log("I");
```

答：ACEIHBD

解析：里面有个两个细节需要注意，一个是`while (new Date() - start < 3000)`执行完毕后，已经过了3秒，此时第一个`setTimeout`已经达到了执行条件，所以他比第二个`setTimeout`先执行。

第二个细节是，`Promise`中`foo.bar()`未定义，因此会执行`catch`微任务



### 题9

问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    throw new TypeError('错误拉')
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err); // 打印TypeError:错误拉
});
```

解析：上面的`Promise`代码相当于：

```js
const p1 = new Promise((resolve, reject) => {
    try {
        throw new TypeError('错误拉')
    } catch(e) {
        reject(e);
    }
});
```

或：

```js
const p1 = new Promise((resolve, reject) => {
    reject(new TypeError('错误拉'));
});
```



再问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        throw TypeError('错误拉');
    }, 0);
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err);
});
```

答：没有打印，浏览器直接报错TypeError

解析：和`JS`执行机制以及`Promise`捕获异步异常有关，可进行如下修改;

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        try {
            throw TypeError('错误拉');
        } catch (e) {
            reject(e);
        }
    }, 0);
});
```



# 算法

### 判断链表是否有环











