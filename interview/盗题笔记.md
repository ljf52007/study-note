如果每道题都能精雕细琢,完全吃透,面试的时候不敷衍,不潦草,回答出让面试官满意的答案,那你在面试这关,基本无敌.

# `HTML`

### `HTML5`语义化的理解

1. 语义化的背景:

   以前的`HTML`的结构,基本上就是`div+css`,然而,`div`并没有什么实际意义,全靠`css`显示页面的样式.后来,开发者提出了`HTML`结构的语义化,`w3c`也制定出了语义化标签.

2. 什么是语义化:

   语义化就是构成`HTML`结构的标签要有意义,比如有这样的标签:`head`表示头部,`main`表示内容主体,`footer`表示页面底部.那么这些标签构成的`HTML`结构就是语义化的.如果头部,主体,底部都用`div`来表示,那么他就不是一个语义化的`HTML`结构了.

3. 怎么知道页面结构是否语义化?

   可以去掉`css`,看`html`代码的结构是否清晰,再看页面内容呈现是否便于阅读;

4. 为什么要语义化?

   - 对于开发者来说,更加容易开发,阅读与维护;
   - 对于爬虫,搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重,有利于`SEO`;
   - 对于浏览器来说,语义化的`html`结构更加清晰,更加方便解析;
   - 对于用户,能提供更好的用户体验——一是假如`css`加载失败,页面也能呈现出良好的结构,二是某些标签如`label`和有些标签属性如`alt`,`title`能带来良好的用户体验;三是在特殊终端如视障阅读器中语义化的`HTML`可以呈现良好的结构.

5. 如何做到语义化?

   - 用正确的标签做正确的事情,如尽量不使用样式标签`b,font`;强调文本放在`strong,em`中,不使用`b,i`等;使用表格`table`时,标题用`caption`,表头用`thead`,主体用`tbody`,尾部用`tfoot`,表头节点用`th`,单元格用`td`;`input`标签通过`id`属性或`for`属性与`label`标签关联等等;
   - `html`语义化,`css`类名也要语义化;
   - `html5`新增了一些语义化标签,如`header,footer,nav,aside,article`等等;



# `JS`

### `JS`为什么单线程,有什么办法多线程吗?

1. 首先区分进程与线程的概念.

   本质上来说,这两个名词都是`CPU`工作时间片上的一个描述.

   进程描述了`CPU`在运行指令及加载和保存上下文所需的时间,放在应用上来说就是一个程序.线程是进程中的更小单位,描述了执行一段指令所需的时间.

   把这些概念放到浏览器来说,当我们打开一个`Tab`页,其实就是创建了一个进程,一个进程中可以有多个线程,如`渲染线程,JS引擎线程,http请求线程`等等.比如,当我们发出一个请求时,其实就是创建了一个线程,当请求结束后,该线程可能会被销毁.

2. `JS`为什么是单线程?

   `JavaScript`作为浏览器的脚本语言,主要用途是与用户互动,操作`DOM`等,这决定了它只能是单线程,否则会带来复杂的同步问题.

   比如,前面提到了`JS引擎线程和渲染线程`,这两个线程是互斥的,`JS`运行时可能会阻塞渲染.这是因为`JS`可以修改`DOM`,如果`JS`执行的时候渲染线程也在工作,就可能导致不能安全的渲染界面.例如,假如同时有两个线程在工作,一个线程在某个`DOM`节点上添加内容,另一个线程却删除了这个节点,这就导致了冲突.

   所以,单线程有单线程的好处,得益于`JS`是单线程运行的,可以达到节省内存,节约上下文切换时间,没有锁的问题等好处.

3. 有什么办法多线程吗?

   为了利用多核`CPU`的计算能力,`HTML5`提出了`Web Worker`标准,允许`JavaScript`脚本创建多个线程,但是子线程完全受主线程的控制,且不得操作`DOM`.因此,这个新标准并没有改变`JavaScript`单线程的本质.

4. 单线程带来的问题和解决方法

   `JavaScript`单线程就意味着,所有任务需要排队执行,前一个任务结束,才会执行下一个任务.如果前一个任务耗时很长,后一个任务也不得不一直等着.

   如果排队是因为计算量大,`CPU`忙不过来也就算了,但很多时候`CPU`是闲着的,因为`IO`设备(输入输出设备)很慢(比如`Ajax`请求数据),不得不等着结果出来,再往下执行.

   `JavaScript`语言的设计者意识到,这时主线程完全可以不管`IO`设备,挂起处于等待中的任务,先运行排在后面的任务.等到`IO`设备返回了结果,再回过头,把挂起的任务继续执行下去.

   于是,所有的任务可以分为两种——`同步任务和异步任务`.`同步任务`指的是,在主线程上排队执行的任务,只有前一个任务执行完毕,才能执行后一个任务;`异步任务`指的是,不进入主线程,而进入`任务队列(task queue)`的任务,只有`task queue`通知主线程,某个异步任务可以执行了,该任务该会进入主线程执行.



### 事件循环

1. 事件与回调函数

   `任务队列(task queue)`是一个事件的队列,主线程读取`任务队列`,就是读取里面有哪些事件.`IO`设备完成一项任务,就在`任务队列`中添加一个事件,表示相关的异步任务可以进入`执行栈`了.除了`IO`设备的事件以外,还包括一些用户产生的事件(如鼠标点击,页面滚动等等).只要指定`回调函数`,这些事件发生时就会进入`任务队列`,等待主线程读取.

   所谓`回调函数(callback)`,就是那些会被主线程挂起来的代码.异步任务必须指定回调函数,当主线程开始执行异步任务,就是执行对应的回调函数.

2. 宏任务和微任务

   任务源可以分为`微任务(microtask)`和`宏任务(macrotask)`.在`es6`中,`microtask`称为`jobs`,`macrotask`称为`task`.不同的任务源会被分配到不同的`task`队列中.

   `宏任务:`

   - `script`
   - `setTimeout`
   - `setInterval`
   - `setImmediate`
   - `I/O`
   - `UI Rendering`

   `微任务:`

   - `process.nextTick`
   - `promise.then catch`
   - `finally`
   - `Object.observe`
   - `MutationObserver`

   > 注意,**代码不是任务**.如果面试官笑眯眯地问你"在控制台输入一行代码`console.log()`,它是宏任务吗?"可不能傻傻的回答是.
   >
   > 所谓任务,浅显的说就是代码块开始执行的入口(确切地说,是函数栈的入口).而在`JS`中,除了`script整体代码块`以外,所有代码块的入口都是`回调函数`,回调函数被注册到事件后不会马上执行,而是保存在`任务队列`,保存起来待执行的才能算`任务`,然后才有宏任务和微任务之分.
   >
   > `script整体代码块`的特殊之处,在于它的入口不是`回调函数`,但是我们可以浅显地将其看成是被放在一个隐形的函数里,作为回调函数被注册到某个事件里(大概是解析完成后会触发的一个事件),这时候这个隐形的函数就成为了一个任务.

3. 事件循环`(Event Loop)`

   宏任务中包括了`script`,浏览器会先执行一个宏任务.一次正确的`Event Loop`顺序是这样的:

   - 执行同步代码,这算第一个宏任务;
   - 执行栈为空时,查询是否有微任务需要执行;
   - 执行所有的微任务;
   - 执行宏任务中的异步代码,开启下一轮`Event Loop`;



### 事件流

1. 什么是`DOM`事件流?

   事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程就叫做`DOM`事件流.

   `DOM`事件流分为三个阶段:

   1. 捕获阶段:事件从`window`发出,自上而下向目标节点传播的阶段;
   2. 目标阶段:事件被目标元素接收,开始处理事件;
   3. 冒泡阶段:事件从目标阶段自下而上向`window`传播的阶段;

2. `DOM`事件流下的性能优化思路

   事件代理（`Event Delegation`），又称之为事件委托。是 `JavaScript` 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是`DOM`元素的事件冒泡。使用事件代理的好处是可以提高性能:

   - 可以大量节省内存占用，减少事件注册，比如在`table`上代理所有`td`的`click`事件就非常棒
   - 可以实现当新增子对象时无需再次对其绑定

3. 需要注意

   - `JS`代码中只可以执行捕获或冒泡其中一个阶段;
   - `onclick`和`attachEvent`只可以得到冒泡阶段;
   - `addEventListener`中,第三个参数为`false(默认)`,表示在冒泡阶段调用事件处理程序,反之为捕获阶段;
   - 有些事件没有冒泡,如`onfocus,onblur,onmouseenter,onmouseleave`;



### 原型链

要讲原型链,首先要讲几个概念.

- 构造函数:任何一个函数,如果前面加了`new`,那就是构造函数;
- 实例:构造函数通过`new`生成实例;
- `prototype`:所有的函数都有`prototype`属性,指向原型对象;
- `__proto__`:



### 继承

### 闭包

### `new`对象

### 

### `ts`的特点,有什么缺点,与`js`对比

### `Node`和`JS`事件循环对比

### 对`Node`有什么了解?

### 浅拷贝和深拷贝

### 深拷贝边界问题

### `async`和`defer`



### 数组方法





### `es6`用过什么?

1. `let,const`:声明变量的关键字

   |         | 作用域       | 变量提升       | 内存地址是否可以更改 |
   | ------- | ------------ | -------------- | -------------------- |
   | `var`   | 函数级作用域 | 变量提升       | 可更改               |
   | `let`   | 块级作用域   | 不存在变量提升 | 可更改               |
   | `const` | 块级作用域   | 不存在变量提升 | 不可更改             |
   
   - 块级作用域:

     ```js
     if (true){
     	let a = 10;
     }
     console.log(a); //ReferenceError: a is not defined
     ```
   
   - 暂时性死区:

     ```js
     var tmp = 123;
     if(true){
     	tmp = 'abc';
     	let tmp;
     } //ReferenceError: Cannot access 'tmp' before initialization
     ```
   
   - 不存在变量提升:

     ```js
     a = 1
     console.log(a)//ReferenceError: Cannot access 'a' before initialization
     let a
     ```
   
   - `const`声明常量必须赋值

     ```js
     const PI; //SyntaxError: Missing initializer in const declaration
     ```
   
   - `const`声明常量赋值后,值(内存地址)不能修改

     ```js
     const PI = 3.14;
     PI = 10; //Assignment to constant variable.
     ```
   
     ```js
     const arr = [100,200];
     arr[0] = 1;
     arr[1] = 2;
     console.log(arr); //[1,2]
     arr = [3,4]; //error:Assignment to constant variable.
     ```
   
     在`ES6`中，常量的含义是指向的对象不能修改，但是可以改变对象内部的属性.

   > 经典面试题:下面代码输出结果是什么?
   >
   > ```js
   >  var arr = [];
   >  for (var i = 0; i < 2; i++) {
   >      arr[i] = function () {
   >          console.log(i); 
   >      }
   >  }
   > arr[0](); // 2
   > arr[1](); // 2
   > ```
   >
   > 这道题的关键点在于变量`i`是全局作用域下的变量,函数执行时输出的`i`都是全局作用域下的`i`值.
   >
   > 
   >
   > 下面代码输出结果是什么?
   >
   > ```js
   > let arr = [];
   >  for (let i = 0; i < 2; i++) {
   >      arr[i] = function () {
   >          console.log(i); 
   >      }
   >  }
   >  arr[0](); //0
   >  arr[1](); //1
   > ```
   >
   > 此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的`i`值.
   
2. 解构赋值

   > 数组解构

   ```js
   let [a,b,c] = [1,2,3];
   console.log(a); //1
   console.log(b); //2
   console.log(c); //3
   ```

   如果解构不成功，变量的值为undefined：

   ```javascript
   let [a] = [];
   console.log(a); //undefined
   let [b,c] = [1];
   console.log(b); //1
   console.log(c); //undefined
   ```

   > 对象解构

   ```js
    let person = { name: 'zhangsan', age: 20 }; 
    let { name, age } = person;
    console.log(name); // 'zhangsan' 
    console.log(age); // 20
   ```

   ```js
   let {name: myName, age: myAge} = person; // myName myAge 属于别名
    console.log(myName); // 'zhangsan' 
    console.log(myAge); // 20
   ```

3. 剩余参数

   剩余参数语法允许我们将一个不定数量的参数表示为一个数组:

   ```js
   function fn(a,...b){
   	console.log(a); //1
   	console.log(b); //[2,3,4]
   }
   fn(1,2,3,4);
   ```

   剩余参数语法允许和解构赋值配合使用:

   ```js
   let students = ['张三','李四','王五'];
   let [a,...b] = students;
   console.log(a); //张三
   console.log(b); //["李四", "王五"]
   ```

4. 箭头函数

   > 箭头函数与普通函数的区别

   - 箭头函数不绑定`this`关键字,箭头函数中的`this`,指向的是函数定义位置的上下文`this`.即向外层作用域中,一层一层查找`this`,直到有`this`的定义;
   - 箭头函数不可以当做构造函数,不可以使用`new`命令,否则会抛异常;
   - 箭头函数不可以使用`arguments`对象,该对象在函数体内不存在.如果要使用,可以用`Rest`代替;
   - 箭头函数不可以用`yield`命令,因此箭头函数不可以用作`Generator`函数;

   

   > 下面代码输出什么结果?
   >
   > ```js
   > var age = 100;
   > var obj = {
   > 	age: 200,
   > 	say: () => {
   >          console.log(this); // window
   > 		console.log(this.age); // 100
   > 	}
   > }
   > obj.say();
   > ```

   箭头函数不绑定`this`,在`say`函数体中的`this`,指向的是`window`.

   

   > 下面代码输出什么结果?
   >
   > ```js
   > const obj = {
   >   foo() {
   >     console.log(this); // obj
   >     setTimeout(function () {
   >       setTimeout(function () {
   >         console.log(this); // window
   >       })
   > 
   >       setTimeout(() => {
   >         console.log(this); // window
   >       })
   >     });
   > 
   >     setTimeout(() => {
   >       setTimeout(function () {
   >         console.log(this); // window
   >       })
   > 
   >       setTimeout(() => {
   >         console.log(this); // obj
   >       })
   >     })
   >   }
   > }
   > obj.foo();
   > ```

   这道题的关键是理解`setTimeout`内回调函数的`this`指向问题.《`JavaScript`高级程序设计》第二版中写到,"超时调用的代码都是在全局作用域中执行的,因此函数中`this`的值在非严格模式下指向`window`对象,严格模式下是`undefined`".

   但是,如果回调函数是箭头函数,那么它的`this`指向依旧是当前函数体的上下文`this`.

   现在我们一步一步来看上面的打印结果.

   - 第一个打印`obj`:`obj`调用了`foo`函数,`foo`函数体的`this`指向`obj`;

   - 第二个打印`window`:`setTimeout`回调函数是普通函数,函数体的`this`指向`window`;

   - 第三个打印`window`:`setTimeout`回调函数是箭头函数,函数体的`this`指向当前上下文`this`,由于该`setTimeout`是在另一个`setTimeout`回调函数(普通函数)的函数体中,因此该上下文`this`指向`window`;

   - 第四个打印`window`:理由同二;

   - 第五个打印`obj`:`setTimeout`回调函数是箭头函数,函数体的`this`指向当前上下文`this`;由于该`setTimeout`是在另一个`setTimeout`回调函数(箭头函数)的函数体中,因此该上下文`this`指向`obj`;

5. 扩展运算符`...`

   > `ES6`扩展运算符能解决什么问题?

   - `浅拷贝`

     `数组浅拷贝`

     数组的扩展运算符可以将数组转换为以逗号隔开的参数序列.

     如果想拷贝一个数组,以下的方法是错误的:                    

     ```js
     let arr1 = [1,2,3];
     let arr2 = arr1; // 这样拷贝是错误的,它会导致下面的问题
     arr2[0] = 4;
     console.log(arr1[0]); // 4 修改arr2,arr1受到影响
     ```

     可以像这样拷贝数组:

     ```js
     let arr1 = [1,2,3];
     let arr2 = [...arr1]; // 扩展运算符拷贝
     arr2[0] = 4;
     console.log(arr1[0]); // 1 修改arr2,arr1不受影响
     ```

     `对象浅拷贝`

     对象的扩展运算符用于取出参数对象中所有可遍历的属性,拷贝到当前对象之中;

     ```js
     let foo = {a: 1, b: 2};
     let bar = {...foo}; // {a: 1, b: 2}
     ```

     上述方法实际上等价于:

     ```js
     let foo = {a: 1, b: 2};
     let bar = Object.assign({}, foo); // {a: 1, b: 2}
     ```

     

   - 数组或对象的拼接

     `数组拼接`

     根据数组扩展运算符的特点,可以如下拼接数组:

     ```js
     let arr1 = [1,2,3];
     let arr2 = [4,5,6];
     let arr3 = [...arr1, ...arr2];
     ```

     `对象拼接`

     `Object.assign()`用于对象的拼接(合并),第一个参数是目标对象,后面的参数都是源对象.如果目标对象与源对象有同名属性,或多个源对象有同名属性,则后面的属性会覆盖前面的属性.

     ```js
     const obj1 = {a: 1, b: 2};
     const obj2 = Object.assign({a: 0}, obj1); // {a: 1, b: 2}
     ```

     同样,如果用户自定义的属性放在扩展运算符后面,则同名属性会被覆盖掉;

     ```js
     const obj1 = {a: 1, b: 2};
     const obj2 = {...obj1, ...{a: 4, c: 3}}; // {a: 4, b: 2, c: 3}
     ```

     

   - 将类数组转化为真正的数组

     ```js
     let oDivs = document.getElementsByTagName('div'); // 类数组
     oDivs = [...oDivs]; // 转换为真正的数组
     ```

6. 模板字符串``

   - 可以解析变量
   - 可以调用函数
   - 可以换行

7. 数组方法`find(),findIndex(),includes()`

8. 字符串方法`startWith(),endWith(),repeat()`

9. 集合——`Set数据结构`

   `ES6`提供了新的数据结构`Set`,即集合,它类似于数组,但是成员的值都是**唯一**的,没有重复的值.

   - 实例化

     `Set`本身也是一个构造函数,用来生成`Set`数据结构

     ```js
     const s = new Set();
     ```

     `Set`函数可以接受一个数组作为参数,用来初始化,会去掉数组中重复的值.

     ```js
     const s = new Set([1,2,3,4,4]); // [1,2,3,4]
     ```

   - 实例方法

     - `add(value)`:添加某个值,返回集合本身;
     - `delete(value)`:删除某个值,返回一个布尔值,表示删除是否成功;
     - `has(value)`:返回一个布尔值,表示该值是否为`Set`的成员;
     - `clear()`:清除所有成员,没有返回值

     ```js
     const s = new Set([1,2,3,4]);
     s.add(4).add(5);
     console.log(s); // Set(5) {1,2,3,4,5}
     console.log(s.delete(4)); // true
     console.log(s.has(4)); // false
     s.clear();
     console.log(s); // Set(0) {}
     ```

     - 遍历方法`forEach`

       `Set`结构的实例与数组一样,拥有`forEach`方法,用于对每个成员执行某种操作,没有返回值;

       ```js
       s.forEach((value, index, set) => console.log(value, index, set));
       ```

       其中回调函数里第一个参数是当前值,第二个是索引(从1开始),第三个是集合本身.

10. `Promise`



### 说下`Promise`,`Promise`有什么缺点,手写

### 跨域

### `canvas`相关,它有跨域问题吗

### 

### `js`去重的方法

### 判断是否为数组的方法？优缺？

1. 不能用typeof，typeof只能判断数组为object，不能明确为Array

2. 不能用.length，因为其他诸如函数也有length属性

3. instanceof，可以判断，instanceof是通过原型链去判断数据类型的，但是存在框架问题（如果从一个框架传一个数组到另一个框架，instanceof可能会找不到构造函数）

4. Array.isArray()，可以判断，老版本的浏览器不支持

5. Object.prototype.toString.call()

   ```js
   var arr = [];
   Object.prototype.toString.call(arr) == "[object Array]"; // true
   ```

   

### `window`有哪些对象？

主对象主要有：`document`对象，`frames`对象，`history`对象，`location`对象，`navigator`对象，`screen`对象

# `CSS`

### `css`盒模型

### 一个弹窗实现居中布局怎么做

### 实现元素垂直上下居中的方法

### `flex: 1`表示什么

### `BFC`,`IFC`



# 浏览器

### 浏览器缓存

### 浏览器存储,`cookie`,`localStorage`,`sessionStorage`,`indexdb`

### 浏览器输入`URL`发生了什么

### 浏览器页面渲染流程

#### 渲染流程

> 浏览器渲染流程是什么?

渲染的过程其实就是将`url`对应的各种资源, 通过浏览器渲染引擎的解析,输出可视化的图像:

```
HTML/CSS/JavaScript => 浏览器渲染引擎 => 图像
```

1. 浏览器解析`HTML`文件为`DOM`树

   当我们打开一个网页,浏览器请求对应的`HTML`(在网络传输中是0和1的字节数据),将这些字节数据转换为字符串(我们写的代码).

   接着再将字符串通过词法分析转换为标记(`token`),这一过程在词法分析中称为标记化(`tokenization`).

   ```
   那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思
   ```

   结束标记后,这些标记会紧接着被转换为`Node`,最后根据这些`Node`之间的联系,构建`DOM`树.

   ```
   字节数据 => 字符串 => token => Node => DOM树
   ```

2. 将`CSS`文件转换为`CSSOM`树(`CSS`对象模型树)

   这一过程与构建`DOM`树是相似的.

   ```
   字节数据 => 字符串 => token => Node => CSSOM树
   ```

   在这一个过程中,浏览器会确认每一个节点的样式是什么,并且这个过程是很消耗资源的(样式的设置是多样化的).因此,我们应该尽可能的避免写过于具体的`CSS`选择器,如`div > a > span`,然后对于`HTML`来说,也尽量少的添加无意义标签,保证层级扁平.

   根据页面渲染流程可得知:

   - `css`加载不会阻塞`DOM`树的解析,但会阻塞`DOM`树的渲染;
   - `css`加载会阻塞后面`js`语句的执行

   

3. 生成`Render Tree`(渲染树)

   生成`DOM`树和`CSSOM`树后,就会将这两颗树组合为渲染树.

   ```
   这一过程并不是简单的合并,`render tree`只会包括需要显示的节点和这些节点的样式信息,比如,如果某个节点的样式是`display:none`,就不会在`render tree`中显示.
   ```

4. 浏览器生成`render tree`后,就会根据`render tree`来进行布局(也叫回流或者重排),然后调用`GPU`绘制,合成图层,显示在屏幕上.

#### 阻塞渲染

> 什么情况会阻塞渲染?怎么解决?

| 阻塞                                                         | 解决                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 渲染的前提首先是生成渲染树,因此`HTML`和`CSS`的解析肯定会阻塞渲染 | 应该从一开始降低需要渲染的文件大小,比如`HTML`保证层级扁平,`CSS`优化选择器 |
| 浏览器解析到`script`标签时,会暂停`DOM`的构建.解析完`js`后才会从暂停的地方重新开始构建 | 不应该在首屏加载`js`文件,将`script`标签至于`body`底部(当然,也可以添加`defer`和`async`属性)<br />`defer`属性表示该`js`文件会并行下载,但是会放到`HTML`解析完成后执行.<br />对于没有任何依赖的`js`文件可以添加`async`属性,表示`js`文件的下载和解析不会阻塞渲染. |



#### 重绘&回流

- 重绘(`repaint`): 当渲染树中的元素外观(如:`color`)发生改变,不影响布局时,产生重绘;
- 回流(`reflow`): 当渲染树中的元素布局(如:尺寸,位置,隐藏状态)发生改变时,产生回流(重排);
- 当`JS`获取`Layout`的属性值(如:`offsetLeft,scrollTop,getComputedStyle`等),也会引起回流,因为浏览器需要通过回流重新计算最新的值;
- 回流必将引起重绘,而重绘不一定会引起回流;

> 如何针对重绘和回流进行前端优化?

1. 需要对元素进行复杂的操作时,可以先隐藏 该元素(`display:none`),操作完成以后,再显示;
2. 需要创建多个`DOM`节点时,使用`DocumentFragment`创建完后一次性地加入`document`;
3. 缓存`Layout`的属性值,如:`let left = elem.offsetLeft`,这样多次使用`left`只产生第一次的回流;
4. 尽量避免使用`table`布局,`table`元素一旦触发回流就会导致`table`里所有的其他元素回流;
5. 尽量避免`css`表达式(`expression`),因为每次调用都会重新计算值(包括加载页面);
6. 尽量使用`css`属性的简写,如用`border`代替`border-width,border-style,border-color`;
7. `JS`中批量修改元素的样式,如:`elem.className`和`elem.style.cssText`代替`elem.style.xxx`;



#### `DOM`操作

>操作`DOM`性能为什么会变差?

1. `DOM`属于渲染引擎,`JS`属于`JS`引擎,通过`JS`操作`DOM`涉及了两个线程之间的通信,势必会带来一些性能的损耗.操作`DOM`的次数一多,就等同于一直在进行线程之间的通信.
2. 操作`DOM`可能会带来重绘和回流的情况.

> 经典面试题:插入几万个`DOM`,怎么实现页面不卡顿?

首先,不可能把几万个`DOM`一次性插入,这样做是绝对会卡顿的,解决问题的关键应该从减少`DOM操作次数`和`缩短循环时间`两个方面去减少主线程阻塞的时间.

1. `DocumentFragment`

   减少`DOM`操作次数的良方是`createDocumentFragment API`,它用来创建一个虚拟的节点对象,或者说,是用来创建文档碎片节点.`DocumentFragment`节点不属于文档树,继承的`parentNode`属性总是`null`.

   `DocumentFragment`有一个很实用的特点,当请求把一个`DocumentFragment`节点插入文档树时,插入的不是`DocumentFragment`自身,而是它的所有子孙节点.这使得它起到了一个暂存节点的作用.因此,当需要添加多个`dom`元素时,如果先将这些元素添加到`DocumentFragment`中,再统一将`DocumentFragment`添加到`DOM`树种的节点,可以减少页面渲染`DOM`的次数,效率明显提升.

   以下是原生插入3万个节点和利用`DocumentFragment`插入3万个节点的对比:

   ```js
   // 原生插入
   console.time('原生插入耗时')
   
   const list = document.getElementById('ul');
   let insertCount = 30000; // 插入的节点数
   let count = 0; // 当前已插入的节点数
   function protoRender() {
     while (count <= insertCount) {
       const li = document.createElement('li');
       li.innerHTML = `原生插入节点${count}`;
       list.appendChild(li);
       count++;
     }
   }
   protoRender();
   
   console.timeEnd('原生插入耗时'); // 原生插入耗时: 154.080322265625 ms
   ```

   ```js
   // DocumentFragment 插入
   console.time('DocumentFragment插入耗时')
   
   const list = document.getElementById('ul');
   let insertCount = 30000;
   let count = 0;
   function fragmentRender() {
     const fragment = document.createDocumentFragment();
     while (count <= insertCount) {
       const li = document.createElement('li');
       li.innerHTML = `DocumentFragment记录${count}`;
       fragment.appendChild(li);
       count++;
     }
     if (count > insertCount) {
       list.appendChild(fragment);
     }
   }
   fragmentRender();
   
   console.timeEnd('DocumentFragment插入耗时'); // DocumentFragment插入耗时: 151.240234375 ms
   ```

2. 通过`requestAnimationFrame`(`rAF`)的方式循环插入`DOM`

   现代浏览器提供了`requestAnimationFrame``API`来解决非常耗时的代码段对渲染的阻塞问题.,`DocumentFragment`可以减少`DOM`操作次数,`requestAnimationFrame`可以保证新节点操作在页面重绘前执行,二者结合可以实现数据渲染优化.

   ```js
   // DocumentFragment && requestAnimationFrame
   console.time('rAF插入耗时');
   
   const list = document.getElementById('ul');
   const total = 30000; // 需要插入的节点数
   const insertCount = 51; // 一次插入的节点数
   const insertTimes = Math.ceil(total / insertCount); // 需要处理的批次数
   let finishCount = 0; // 已经插入的批次数
   function fragmentRender() {
     const fragment = document.createDocumentFragment();
     const count = total - (finishCount * insertCount); // 未插入的节点数
     const forCount = count >= insertCount ? insertCount : count; // 需要遍历的节点数
     for (let i = 0; i < forCount; i++) {
       const li = document.createElement('li');
       li.innerHTML = `rAF记录${finishCount * insertCount + i + 1}`;
       fragment.appendChild(li);
     }
     list.appendChild(fragment);
     finishCount++;
     rAfRender();
   }
   
   function rAfRender() {
     if (finishCount < insertTimes) {
       window.requestAnimationFrame(fragmentRender);
     }
   }
   rAfRender();
   
   console.timeEnd('rAF插入耗时'); // rAF插入耗时: 0.15771484375 ms
   ```

3. 虚拟滚动`virtualized scroller`,这种技术的原理就是只渲染可视区域内的内容,非可见区域的就完全不渲染.当用户滚动的时候,实时替换渲染的内容.



# `Vue`

### 父子组件如何通信?非父子组件如何通信?

### 组件传参

### 父组件向子组件传入动态的值怎么处理?

### 为啥拿`vuex`的数据你用`getter`去拿,不用`state`

### 说下`vuex`,`vuex`的数据什么时候消失?怎么实现持久存储?

### 存储`token`的过程说一下

### `axios`的使用

### `vue`使用`axios`怎么终止请求,实现原理是什么

### `keep-alive`的应用场景,及相关的生命周期

### `Angular`和`Vue`对比,优缺点,为什么公司用`angular`?

### `Angular`和`Vue`的生命周期

### `vue`生命周期`dom`什么时候可以操作

### `created`有什么方法可以实现`dom`操作吗

### `vue`路由钩子

### 权限问题,权限的实现方式

### `vue`响应式原理

### `vue`响应式原理,为什么检测不到数组长度变化

### `vue3`的了解程度

### `vue2`和`vue3`双向绑定的差异

### nextTick的存在意义是什么？

因为vue是异步更新Dom的，一旦观察到数据更新呢，就会开开一个队列，然后把当前事件循环中观察到的watcher加入到这个队列，即便watcher触发多次，也推送一次，而在下一个事件循环开始，vue进行必要的dom操作，并且清空队列，而nextTick是在dom更新后和队列清空后额外加入的一个操作。

### `nexttick`源码

### `vue`与`react`的`hook`有什么区别

### 路由参数两种模式的区别

### 路由`history`模式怎么监听变化,`hash`模式的缺点

### `v-for`中的`key`

### `v-for`和`v-if`为什么不建议一起用

### 组件异步加载

### 路由懒加载

### 为什么`data`是一个返回对象的函数

### `computed`和`watch`区别(缓存,异步)

### 虚拟`dom`和`diff`

### 使用第三方组件(如`element-ui,iview`),如何实现样式的覆盖?

### `vue`中轮播图组件的开发流程(简略代码实现,页面布局,功能)

### 列出至少4种`vue`当中的指令和它的用法,如何自定义`vue`指令

### `vue-router`中`$router`与`$route`的区别

### `vue`事件总线



# HTTP

### `Web`安全,预防措施

### 说说常见的请求头和响应码,301和302的区别是什么

### `tcp`三次握手具体过程

### `http`缓存你了解多少

### `get`和`post`的相同点和不同点

# `Webpack`

### `Webpack`配置过吗?用`webpack`怎么配置来优化,用过代理吗?

### `webpack`由哪几个组成?

### `loader`和`plugin`差别

### 如何打包分成多个`js`

### 如何配置多个`index.html`(多页面应用)[输出传数组]

### 常用的`plugin`

### 摇树优化





# 手写 

### 手写防抖

```js
function debounce(fn, wait = 500) {
  // 初始化一个计时器
  let timer = 0;
  return function(...arg) {
   	// 将已存在的计时器删除，并重新定义一个新的计时器
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      // apply指定this指向
      fn.apply(this, arg);
    }, wait)
  }
}
```



### 手写节流

```js
function throttle(fn, wait = 500) {
  // 初始化lastTime
  let lastTime = 0;
  return function(...arg) {
    // 保存当前操作的时间
    let now = +new Date();
    if (now - lastTime > wait) {
      // 如果当前操作时间和lastTime的差值大于设定的等待时间，则执行函数
      fn.apply(this, arg);
      // 将当前时间赋值给lastTime，为下一次操作做准备
      lastTime = now;
    }
  }
}
```



### 手写深拷贝

（解决循环引用问题，未解决函数类型深拷贝，以及不可遍历的特殊类型深拷贝）

```js
// 深拷贝
function deepCopy(oldObj, map = new Map()) {
  // 如果已经拷贝过，直接return，解决循环引用问题
  if (map.get(oldObj)) return oldObj;
  // 如果是值类型或null（这里没有考虑到函数function类型）
  if (typeof oldObj !== 'object' ||  oldObj === null) return oldObj;
  // map保存键值对
  map.set(oldObj, true);
  let newObj = Array.isArray(oldObj) ? [] : {};
  for (const key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      // 递归拷贝
      newObj[key] = deepCopy(oldObj[key], map);
    }
  }
  return newObj;
}


const deepCopy = function (target, cache = []) {
  for (let i = 0; i < cache.length; i++) {
    if (cache[i].target === target) {
      return cache[i].result;
    }
  }

  const type = Object.prototype.toString.call(target).slice(8, -1);
  let result = null;
  if (['String', 'Number', 'Boolen', 'Undefined', 'Null', 'Symbol', 'BigInt'].includes(type)){
    return target;
  } else if (type === 'Object'){
    result = {};
  } else if (type === 'Array') {
    result = [];
  } else if (type === 'Date') {
    result = new Date(target);
  } else if (type === 'RegExp') {
    result = new RegExp(target.source, target.flags);
  } else if (type === 'Function') {
    result = target.bind(this);
  } 

  cache.push({target, result});

  for (const key in target) {
    if (target.hasOwnProperty(key)) {
      result[key] = deepCopy(target[key], cache);
    }
  }
  return result;
}

export default deepCopy;
```



### 手写Event Bus

```js
class EventEmeitter {
  constructor() {
    // map类型存储type-fn键值对
    this._events = this._events || new Map();
    this.maxListeners = this.maxListeners || 10;
  }

  // 监听名为type的事件
  addListener(type, fn) {
    const handler = this._events.get(type);
    if (!handler) {
      // 如果handler不存在，则说明该类型事件未监听
      this._events.set(type, fn);
    } else if (handler && typeof handler === 'function') {
      // handler存在且handler是函数，说明只有一个监听者
      this._events.set(type, [handler, fn]); // 多个监听者需要用数组存储
    } else {
      // handler本身是数组
      handler.push(fn);
    }
  }

  removeListener(type, fn) {
    const handler = this._events.get(type);
    if (handler && typeof handler === 'function') {
      // 如果handler是函数，说明只有一个监听者，直接删
      this._events.delete(type, fn);
    } else if (Array.isArray(handler)) {
      // handler是数组，则需要遍历数组，找到对应的函数删除
      let position = -1;
      for (let i = 0; i < handler.length; i++) {
        if (handler[i] === fn) position = i;
        break;
      }
      if (position !== -1) {
        // 删除对应的fn
        handler.splice(position, 1);
        // 如果清除后只有一个函数,那么取消数组,以函数形式保存
        if (handler.length === 1) {
          this._events.set(type, handler[0]);
        }
      } else {
        return this;
      }
    }
  }

  emit(type, ...args) {
    let handler = this._event.get(type);
    // 如果没有handler，说明没有监听type事件，直接返回false
    if (!handler) return false;
    // 如果handler是一个数组，需要遍历数组依次调用
    if (Array.isArray(handler)) {  
      for (let i = 0; i < handler.length; i++) {
        if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
      }
    } else {
      if (args.length > 0) {
        handler.apply(this, args);
      } else {
        handler.call(this);
      }
    }
    return true;
  }
}
```



### 手写instanceof

```js
function MyInstance(instanceObj, func) {
  // 获取实例instanceObj的__proto__
  let protoObj = Object.getPrototypeOf(instanceObj);
  while (true) {
    // 沿着原型链查不到__proto__，说明已经查到了原型链顶端，此时还找不到当前类，返回false
    if (protoObj === null) return false;
    // 在当前实例对象的原型链上，找到了当前类
    if (protoObj === func.prototype) return true;
    // 沿着原型链__proto__一层一层向上查
    protoObj = Object.getPrototypeOf(protoObj);
  }
}
```



### 手写new

```js
function MyNew(fn, ...args) {
  // 创建一个对象（实例），且该对象__proto__指向F的prototype
  let instance = Object.create(fn.prototype);
  // 改变this的指向
  let res = fn.apply(instance, args);
  // 确保返回的结果是一个对象（万一fn不是构造函数）
  return typeof res === 'object' ? res : instance;
}
```



### 手写Object.create()

```js
// 该方法创建一个对象，且该对象的__proto__指向传入的参数proto
Object.prototype.myCreate = (proto) => {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



### 手写call

```js
Function.prototype.myCall =  function(context = window, ...args) {
  // 如果非函数调用myCall，抛出错误
  if (typeof this !== 'function') {
    throw new Error('Not function!');
  }
  // 使用Symbol定义唯一的属性
  let key = Symbol('fn');
  context[key] = this;
  let res = context[key](...args);
  // 删除context[key]释放内存，否则context的属性会越来越多
  delete context[key];
  return res;
}
```

手写apply与手写call是一样的，只需要修改传入参数的方式：

```js
let res = context[key](args);
```



### 手写bind

```js
Function.prototype.myBind = function(context = window, ...outerArgs) {
  // 非函数调用，报错
  if (typeof this !== 'function') {
    throw new Error('Not a function!');
  }
  // 保存this
  let self = this;
  return function F(...innerArgs) {
    // 如果是new的方式，这里的this与self已经不是同一个概念了
    if (this instanceof F) {
      return new self(...outerArgs, ...innerArgs);
    }
    return self.call(context, ...outerArgs, ...innerArgs);
  }
}

let obj = {
  name: 'lujiafeng'
};
function a(name, age) {
  this.name = name;
  this.age = age;
}
const fn = a.bind(obj, 'lilinqi', 18);
const ins = new fn();
console.log(ins);
console.log(obj);
```



### 判断类型

```js
let class2type = {};
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
	if (obj == null) return String(obj);
	return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj;
}
```



### `JS`实现多行省略(不重要)

```html
<div class="box">
  <p class="p" rows='3'>这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字</p>
</div>

<script>
  // 获取需要设置多行省略的标签
  const elBoxs = document.getElementsByClassName('p');
  const elBoxsLength = elBoxs.length;

  // 没有使用forEach(有些浏览器不兼容)和map（标签数组不能使用map的方法）
  for(let i = 0; i < elBoxsLength; i += 1) {
    const el = elBoxs[i];
    let text = el.innerHTML;
    // 需要在第几行省略，是否支持webkitLineClamp属性
    let options = {
      rows: parseInt(el.getAttribute('rows')),
      isSupportlineCamp: `${el.style.webkitLineClamp}` !== 'undefined',
    };

    // 设置需要省略的属性及字体的两端对齐的样式
    el.style.overflow = 'hidden';
    el.style.textOverflow = 'ellipsis';
    el.style.wordBreak = 'break-all';
    el.style.wordWrap = 'break-word';
    el.style.textAlign = 'justify';

    // 支持webkitLineClamp的话直接使用浏览器css样式设置省略号（safari不是很支持，可以直接使用js计算方式），否则通过计算方式
    if(options.isSupportlineCamp) {
      el.style.webkitLineClamp = options.rows;
      el.style.display = '-webkit-box';
      el.style.webkitBoxOrient = 'vertical';
    } else {
      const heightStr = getCurrentStyle(el, 'height');
      const height = getNumber(heightStr);
      const maxHeight = getMaxHeight(el, options.rows, text);
      if(height > maxHeight) {
        subStrChar(el, maxHeight, text);
      } else {
        el.innerHTML = text;
      }
    }
  };

  // 截取字符串，从第一个开始，当前高度大于最大高度时，截取到前一个字符；
  function subStrChar(el, maxHeight, text) {
    console.log(maxHeight);
    let end = false;
    let i = 0;
    while(!end) {
      i++;
      el.innerHTML = text.substring(0, i) + '...';
      const currentHeightStr = getCurrentStyle(el, 'height');
      const currentHeight = getNumber(currentHeightStr);
      if(currentHeight > maxHeight) {
        el.innerHTML = text.substring(0, i - 1) + '...';
        end = true;
      }
      if(i >= text.length) {
        break;
      }
    }
  }

  // 获取最大高度，当line-height为normal的时候，对标签塞入字符，获取一行的行高
  function getMaxHeight(el, rows, text) {
    const lineHeight = getCurrentStyle(el, 'lineHeight');
    let number = 0;

    if(lineHeight === 'normal') {
      let index = 0;
      do {
        el.innerHTML = text[index++];
      } while(!getNumber(getCurrentStyle(el, 'height')));
      number = getNumber(getCurrentStyle(el, 'height'));
    } else {
      number = getNumber(lineHeight);
    }

    return number * rows;
  }

  // 获取当前元素的属性值
  function getCurrentStyle(el, elAttr) {
    // getComputedStyle获取元素的所有CSS属性的值
    return window.getComputedStyle(el)[elAttr]
  }

  // 将获取的字符串值变成向上取整成数字
  function getNumber(str) {
    let number = parseFloat(str);
    return Math.ceil(number)
  }
</script>
```



# 其他

### 登录状态保持实现流程,`jwt`了解吗

### `servicework`

### `token`过期处理

### 手机适配,移动端`1px`变粗

### 预处理器语法

### 性能优化

### 上传大文件优化和处理方式(分片上传,断点续传)

### `ios`图片旋转问题

### `flow-layout`

### 如何验证用户,设备的唯一性

### 网页死机,白屏怎么办

### 语义化版本控制

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

### 你在你的项目中遇到过什么兼容性处理?

1. 后端返回`2021-06-11`这样字符串日期,在安卓上使用`new Date`是正常可以获取时间格式的，但是在`ios`上使用`new Date`会报错，解决方案是把`-`转成`/`,即`new Date('2021/06-11')`;

2. 针对具有刘海屏或底部菜单横条的设备,进行兼容性处理,否则页面布局往往不符合需求

   ```css
   {html{--ion-safe-area-top:var(--ion-statusbar-padding)}}@supports (padding-top:constant(safe-area-inset-top)){html{--ion-safe-area-top:constant(safe-area-inset-top);--ion-safe-area-bottom:constant(safe-area-inset-bottom);--ion-safe-area-left:constant(safe-area-inset-left);--ion-safe-area-right:constant(safe-area-inset-right)}}@supports (padding-top:env(safe-area-inset-top)){html{--ion-safe-area-top:env(safe-area-inset-top);--ion-safe-area-bottom:env(safe-area-inset-bottom);--ion-safe-area-left:env(safe-area-inset-left);--ion-safe-area-right:env(safe-area-inset-right)}}
   ```

3. `ios`系统会将数字当成电话号码,因此会变色,解决方式是在`index.html`的`head`中添加:

   ```xml
   <meta name="format-detection" content="telephone=no"> 
   <meta http-equiv="x-rim-auto-match" content="none">
   ```

4. `input`框聚焦，`ios`会出现`outline`或者阴影，安卓显示正常,解决方式是

   ```css
   input:focus{outline:none}  //去除外边框
   input{-webkit-appearance: none;}
   ```

5. 

### 



# 一些题目

### 题1

样式：

```css
body{
    margin: 0;
    padding: 0;
}
div{
    height: 100px;
    width: 100px;
    left: 200px;
    top: 200px;
}
.div1{
    position: relative;
    background-color: red;
}
.div2{
    position: absolute;
    background-color: blue;
}
.div3{
    position: fixed;
    background-color: pink;
}
.div4{
    background-color: black;
}
```

dom:

```html
<div class="div1"></div>
<div class="div2"></div>
<div class="div3"></div>
<div class="div4"></div> 
```

问：四个div的展示效果是怎样的？

答：div1，2，3重叠，div4定位为static，因此`left`和`top`不起效，但是会被`position: relative`的div1挤下来

![图1](D:\front-end-note\images\面试题\图1.png)



### 题2

样式：

```css
.div1{
    height: 100px;
    width: 100px;
    background-color: red;
}
.div2{
    height: 10px;
    width: 10px;
    background-color: blue;
    margin-top: 50%;
    padding-top: 50%;
}
```

dom：

```html
<div class="div1">
    <div class="div2"></div>
</div>
```

问：界面是怎样的？

答：div2是div1的子级，`margin`和`padding`的百分比应该都是相对于父级的`width`和`height`

![图2](D:\front-end-note\images\面试题\图2.png)

### 题3

js：

```js
var name = 'a';
function outter(){
    var name = 'b';
    function inner(){
    console.log(name);
    console.log(this.name)
    }
    inner()
};
outter()
```

问：打印结果？

答：先b后a



### 题4

dom：

```html
<ul id="test">
    <li>这是第一条</li>
    <li>这是第二条</li>
    <li>这是第三条</li>
</ul>
```

问：点击每一li打印相应的index，请用非闭包，闭包以及事件委托三种方法实现

答：

1. 非闭包：用let

   ```js
   var liList = document.getElementById('test').children;
   for (let i = 0; i < liList.length; i++) {
       liList[i].onclick = function() {
           console.log(i)
       }
   }
   ```

   

2. 闭包：立即执行函数

   ```js
   var liList = document.getElementById('test').children;
   for (var i = 0; i < liList.length; i++) {
       liList[i].onclick = (function (index) {
           return function () {
               console.log(index)
           }
       })(i)
   }
   ```

   

3. e.target

   ```js
   var ulElement = document.querySelectorAll('#test')[0];
   ulElement.addEventListener('click', function(e) {
       if (e.target.nodeName !== 'LI') return;
       // 或 if (e.target.constructor !== HTMLElement) return; 
       var liArr = Array.from(ulElement.children);
       var index = liArr.indexOf(e.target);
       var content = liArr[index].innerHTML;
       console.log(index, content);
   }, false);
   ```

   





### 题5

问：有一个列表，上面有三个条件查询按钮ABC，每点一个按钮就会发送请求进行条件查询，请求时页面会有个`loading`，请求完毕后`loading`会消失。问，如果点了A以后，A尚未请求完就点B，此时应该如何控制`loading`？

答：第一种方法是变量或数组分别存储三个`loading`，分别控制三个查询；

第二种方法是全局定义一个`index = 0`，请求时`index+1`，请求完毕`index-1`，此时判断`index`是否为0，为0则`loading = false`。

第三种方法是请求中断？



### 题6

问：一个列表，里面记录的是任务，然后每一行都可以点击执行，但是这个执行很慢，所以这一行会转圈圈，然后你需要轮循向后端请求，执行完了没有，然后呢，又有一个执行所有的按钮，你点了之后就会执行所有的，而不是当前页的，而且你在第二页执行的loading状态，返回第一页，再返回去第二页，状态是保存的，问，怎么样设计轮训次数最少，后端可以根据你的设计来改。

答：查询当页咯，然后进行筛选，你要保存loading状态，执行完了就不loading



### 题7

问：看下面的代码，输出什么？

```JavaScript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

答：

```js
  Foo.getName(); // 2
  getName(); // 4
  Foo().getName(); // 1
  getName(); // 1
  new Foo.getName(); // 
  new Foo().getName(); // 
  new new Foo().getName(); // 
```

解析：

1. **Foo.getName();**

2. **getName();**

   `function`声明的函数会提升到代码的最前，因此4会将5覆盖，此时执行`getName()`即`window.getName()`，输出4

3. **Foo().getName();**

   `Foo()`执行，执行代码中`getName=function...`，实际上可分为两步，即`var getName;`和`getName=function...`。因此此时全局环境中的`getName`已经被1覆盖。

   `Foo()`的调用对象是`window`，因此`return this`即是`return window`

   因此，`Foo().getName()`即为`window.getName()`，输出1

4. **getName();**

   `getName()`相当于`window.getName()`，输出1

5. **new Foo.getName();**

   这里等价于`new (Foo.getName())`，先执行`Foo.getName()`，输出2，然后new一个实例。

6. **new Foo().getName();**

   这里等价于`(new Foo()).getName()`，先`new`一个`Foo`的实例，再执行这个实例的`getName`。但是这个实例本身没有这个方法，所以根据原型链查找规则，找到`Foo`的原型对象`prototype`上的`getName`方法。输出3

7. `new new Foo().getName();`

   这里等价于new `(new Foo().getName())`，如上述6，先输出3，然后`new`一个实例。

补充：

关于上述5中`new Foo.getName()`先执行`Foo.getName()`，而6中`new Foo().getName()`先执行`new Foo()`，是因为：

- `new Foo()`属于`new`（带参数列表）
- `new Foo`属于`new`（无参数列表）

无参数列表的优先级为18，而成员访问的优先级是19，高于无参数列表。因此`new Foo.getName()`先执行`Foo.getName()`

带参数列表的优先级为19，而成员访问的优先级也为19，按照运算符规则（同一优先级，按照从左到右的执行顺序），`new Foo().getName()`先执行`new Foo()`，再对`new`之后的实例进行成员访问`.getName()`操作。





### 题8

问：下面的代码输出什么？

```js
console.log("A");
setTimeout(() => console.log("B"), 1000);
const start = new Date();
while (new Date() - start < 3000) {}
console.log("C");
setTimeout(() => console.log("D"), 0);
new Promise((resolve, reject) => {
  console.log("E");
  foo.bar(100);
 })
.then(() => console.log("F"))
.then(() => console.log("G"))
.catch(() => console.log("H"));
console.log("I");
```

答：ACEIHBD

解析：里面有个两个细节需要注意，一个是`while (new Date() - start < 3000)`执行完毕后，已经过了3秒，此时第一个`setTimeout`已经达到了执行条件，所以他比第二个`setTimeout`先执行。

第二个细节是，`Promise`中`foo.bar()`未定义，因此会执行`catch`微任务



### 题9

问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    throw new TypeError('错误拉')
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err); // 打印TypeError:错误拉
});
```

解析：上面的`Promise`代码相当于：

```js
const p1 = new Promise((resolve, reject) => {
    try {
        throw new TypeError('错误拉')
    } catch(e) {
        reject(e);
    }
});
```

或：

```js
const p1 = new Promise((resolve, reject) => {
    reject(new TypeError('错误拉'));
});
```



再问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        throw TypeError('错误拉');
    }, 0);
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err);
});
```

答：没有打印，浏览器直接报错TypeError

解析：和`JS`执行机制以及`Promise`捕获异步异常有关，可进行如下修改;

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        try {
            throw TypeError('错误拉');
        } catch (e) {
            reject(e);
        }
    }, 0);
});
```



# 算法

### 判断链表是否有环











