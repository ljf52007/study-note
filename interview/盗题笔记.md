# `Vue`

## 父组件向子组件传入动态的值怎么处理

## 为啥拿vuex的数据你用getter去拿

## 存储token的过程说一下



### 题1

样式：

```css
body{
    margin: 0;
    padding: 0;
}
div{
    height: 100px;
    width: 100px;
    left: 200px;
    top: 200px;
}
.div1{
    position: relative;
    background-color: red;
}
.div2{
    position: absolute;
    background-color: blue;
}
.div3{
    position: fixed;
    background-color: pink;
}
.div4{
    background-color: black;
}
```

dom:

```html
<div class="div1"></div>
<div class="div2"></div>
<div class="div3"></div>
<div class="div4"></div> 
```

问：四个div的展示效果是怎样的？

答：div1，2，3重叠，div4定位为static，因此`left`和`top`不起效，但是会被`position: relative`的div1挤下来

![图1](D:\front-end-note\images\面试题\图1.png)



### 题2

样式：

```css
.div1{
    height: 100px;
    width: 100px;
    background-color: red;
}
.div2{
    height: 10px;
    width: 10px;
    background-color: blue;
    margin-top: 50%;
    padding-top: 50%;
}
```

dom：

```html
<div class="div1">
    <div class="div2"></div>
</div>
```

问：界面是怎样的？

答：div2是div1的子级，`margin`和`padding`的百分比应该都是相对于父级的`width`和`height`

![图2](D:\front-end-note\images\面试题\图2.png)

### 题3

js：

```js
var name = 'a';
function outter(){
    var name = 'b';
    function inner(){
    console.log(name);
    console.log(this.name)
    }
    inner()
};
outter()
```

问：打印结果？

答：先b后a



### 题4

dom：

```html
<ul id="test">
    <li>这是第一条</li>
    <li>这是第二条</li>
    <li>这是第三条</li>
</ul>
```

问：点击每一li打印相应的index，请用非闭包，闭包以及事件委托三种方法实现

答：

1. 非闭包：用let

   ```js
   var liList = document.getElementById('test').children;
   for (let i = 0; i < liList.length; i++) {
       liList[i].onclick = function() {
           console.log(i)
       }
   }
   ```

   

2. 闭包：立即执行函数

   ```js
   var liList = document.getElementById('test').children;
   for (var i = 0; i < liList.length; i++) {
       liList[i].onclick = (function (index) {
           return function () {
               console.log(index)
           }
       })(i)
   }
   ```

   

3. e.target

   ```js
   var ulElement = document.querySelectorAll('#test')[0];
   ulElement.addEventListener('click', function(e) {
       if (e.target.nodeName !== 'LI') return;
       // 或 if (e.target.constructor !== HTMLElement) return; 
       var liArr = Array.from(ulElement.children);
       var index = liArr.indexOf(e.target);
       var content = liArr[index].innerHTML;
       console.log(index, content);
   }, false);
   ```

   

### 题5

问：window有哪些对象？

答：主对象主要有：`document`对象，`frames`对象，`history`对象，`location`对象，`navigator`对象，`screen`对象



### 题6

问：判断是否为数组的方法？优缺？

答：

1. 不能用typeof，typeof只能判断数组为object，不能明确为Array

2. 不能用.length，因为其他诸如函数也有length属性

3. instanceof，可以判断，instanceof是通过原型链去判断数据类型的，但是存在框架问题（如果从一个框架传一个数组到另一个框架，instanceof可能会找不到构造函数）

4. Array.isArray()，可以判断，老版本的浏览器不支持

5. Object.prototype.toString.call()

   ```js
   var arr = [];
   Object.prototype.toString.call(arr) == "[object Array]"; // true
   ```

   

### 题7

问：nextTick的存在意义是什么？

答：因为vue是异步更新Dom的，一旦观察到数据更新呢，就会开开一个队列，然后把当前事件循环中观察到的watcher加入到这个队列，即便watcher触发多次，也推送一次，而在下一个事件循环开始，vue进行必要的dom操作，并且清空队列，而nextTick是在dom更新后和队列清空后额外加入的一个操作。



### 题8

问：有一个列表，上面有三个条件查询按钮ABC，每点一个按钮就会发送请求进行条件查询，请求时页面会有个`loading`，请求完毕后`loading`会消失。问，如果点了A以后，A尚未请求完就点B，此时应该如何控制`loading`？

答：第一种方法是变量或数组分别存储三个`loading`，分别控制三个查询；

第二种方法是全局定义一个`index = 0`，请求时`index+1`，请求完毕`index-1`，此时判断`index`是否为0，为0则`loading = false`。

第三种方法是请求中断？



### 题9

问：一个列表，里面记录的是任务，然后每一行都可以点击执行，但是这个执行很慢，所以这一行会转圈圈，然后你需要轮循向后端请求，执行完了没有，然后呢，又有一个执行所有的按钮，你点了之后就会执行所有的，而不是当前页的，而且你在第二页执行的loading状态，返回第一页，再返回去第二页，状态是保存的，问，怎么样设计轮训次数最少，后端可以根据你的设计来改。

答：查询当页咯，然后进行筛选，你要保存loading状态，执行完了就不loading



### 题10

问：看下面的代码，输出什么？

```JavaScript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

答：

```js
  Foo.getName(); // 2
  getName(); // 4
  Foo().getName(); // 1
  getName(); // 1
  new Foo.getName(); // 
  new Foo().getName(); // 
  new new Foo().getName(); // 
```

解析：

1. **Foo.getName();**

2. **getName();**

   `function`声明的函数会提升到代码的最前，因此4会将5覆盖，此时执行`getName()`即`window.getName()`，输出4

3. **Foo().getName();**

   `Foo()`执行，执行代码中`getName=function...`，实际上可分为两步，即`var getName;`和`getName=function...`。因此此时全局环境中的`getName`已经被1覆盖。

   `Foo()`的调用对象是`window`，因此`return this`即是`return window`

   因此，`Foo().getName()`即为`window.getName()`，输出1

4. **getName();**

   `getName()`相当于`window.getName()`，输出1

5. **new Foo.getName();**

   这里等价于`new (Foo.getName())`，先执行`Foo.getName()`，输出2，然后new一个实例。

6. **new Foo().getName();**

   这里等价于`(new Foo()).getName()`，先`new`一个`Foo`的实例，再执行这个实例的`getName`。但是这个实例本身没有这个方法，所以根据原型链查找规则，找到`Foo`的原型对象`prototype`上的`getName`方法。输出3

7. `new new Foo().getName();`

   这里等价于new `(new Foo().getName())`，如上述6，先输出3，然后`new`一个实例。

补充：

关于上述5中`new Foo.getName()`先执行`Foo.getName()`，而6中`new Foo().getName()`先执行`new Foo()`，是因为：

- `new Foo()`属于`new`（带参数列表）
- `new Foo`属于`new`（无参数列表）

无参数列表的优先级为18，而成员访问的优先级是19，高于无参数列表。因此`new Foo.getName()`先执行`Foo.getName()`

带参数列表的优先级为19，而成员访问的优先级也为19，按照运算符规则（同一优先级，按照从左到右的执行顺序），`new Foo().getName()`先执行`new Foo()`，再对`new`之后的实例进行成员访问`.getName()`操作。





### 题11

问：下面的代码输出什么？

```js
console.log("A");
setTimeout(() => console.log("B"), 1000);
const start = new Date();
while (new Date() - start < 3000) {}
console.log("C");
setTimeout(() => console.log("D"), 0);
new Promise((resolve, reject) => {
  console.log("E");
  foo.bar(100);
 })
.then(() => console.log("F"))
.then(() => console.log("G"))
.catch(() => console.log("H"));
console.log("I");
```

答：ACEIHBD

解析：里面有个两个细节需要注意，一个是`while (new Date() - start < 3000)`执行完毕后，已经过了3秒，此时第一个`setTimeout`已经达到了执行条件，所以他比第二个`setTimeout`先执行。

第二个细节是，`Promise`中`foo.bar()`未定义，因此会执行`catch`微任务



### 题12

问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    throw new TypeError('错误拉')
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err); // 打印TypeError:错误拉
});
```

解析：上面的`Promise`代码相当于：

```js
const p1 = new Promise((resolve, reject) => {
    try {
        throw new TypeError('错误拉')
    } catch(e) {
        reject(e);
    }
});
```

或：

```js
const p1 = new Promise((resolve, reject) => {
    reject(new TypeError('错误拉'));
});
```



再问：下面的代码输出什么？

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        throw TypeError('错误拉');
    }, 0);
});

p1.then(res => {
    console.log(res);
}).catch((err) => {
    console.log(err);
});
```

答：没有打印，浏览器直接报错TypeError

解析：和`JS`执行机制以及`Promise`捕获异步异常有关，可进行如下修改;

```js
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        try {
            throw TypeError('错误拉');
        } catch (e) {
            reject(e);
        }
    }, 0);
});
```



### 语义化版本控制

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。



### 手写防抖

```js
function debounce(fn, wait = 500) {
  // 初始化一个计时器
  let timer = 0;
  return function(...arg) {
   	// 将已存在的计时器删除，并重新定义一个新的计时器
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      // apply指定this指向
      fn.apply(this, arg);
    }, wait)
  }
}
```



### 手写节流

```js
function throttle(fn, wait = 500) {
  // 初始化lastTime
  let lastTime = 0;
  return function(...arg) {
    // 保存当前操作的时间
    let now = +new Date();
    if (now - lastTime > wait) {
      // 如果当前操作时间和lastTime的差值大于设定的等待时间，则执行函数
      fn.apply(this, arg);
      // 将当前时间赋值给lastTime，为下一次操作做准备
      lastTime = now;
    }
  }
}
```



### 手写深拷贝

（解决循环引用问题，未解决函数类型深拷贝，以及不可遍历的特殊类型深拷贝）

```js
// 深拷贝
function deepCopy(oldObj, map = new Map()) {
  // 如果已经拷贝过，直接return，解决循环引用问题
  if (map.get(oldObj)) return oldObj;
  // 如果是值类型或null（这里没有考虑到函数function类型）
  if (typeof oldObj !== 'object' ||  oldObj === null) return oldObj;
  // map保存键值对
  map.set(oldObj, true);
  let newObj = Array.isArray(oldObj) ? [] : {};
  for (const key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      // 递归拷贝
      newObj[key] = deepCopy(oldObj[key], map);
    }
  }
  return newObj;
}


const deepCopy = function (target, cache = []) {
  for (let i = 0; i < cache.length; i++) {
    if (cache[i].target === target) {
      return cache[i].result;
    }
  }

  const type = Object.prototype.toString.call(target).slice(8, -1);
  let result = null;
  if (['String', 'Number', 'Boolen', 'Undefined', 'Null', 'Symbol', 'BigInt'].includes(type)){
    return target;
  } else if (type === 'Object'){
    result = {};
  } else if (type === 'Array') {
    result = [];
  } else if (type === 'Date') {
    result = new Date(target);
  } else if (type === 'RegExp') {
    result = new RegExp(target.source, target.flags);
  } else if (type === 'Function') {
    result = target.bind(this);
  } 

  cache.push({target, result});

  for (const key in target) {
    if (target.hasOwnProperty(key)) {
      result[key] = deepCopy(target[key], cache);
    }
  }
  return result;
}

export default deepCopy;
```



### 手写Event Bus

```js
class EventEmeitter {
  constructor() {
    // map类型存储type-fn键值对
    this._events = this._events || new Map();
    this.maxListeners = this.maxListeners || 10;
  }

  // 监听名为type的事件
  addListener(type, fn) {
    const handler = this._events.get(type);
    if (!handler) {
      // 如果handler不存在，则说明该类型事件未监听
      this._events.set(type, fn);
    } else if (handler && typeof handler === 'function') {
      // handler存在且handler是函数，说明只有一个监听者
      this._events.set(type, [handler, fn]); // 多个监听者需要用数组存储
    } else {
      // handler本身是数组
      handler.push(fn);
    }
  }

  removeListener(type, fn) {
    const handler = this._events.get(type);
    if (handler && typeof handler === 'function') {
      // 如果handler是函数，说明只有一个监听者，直接删
      this._events.delete(type, fn);
    } else if (Array.isArray(handler)) {
      // handler是数组，则需要遍历数组，找到对应的函数删除
      let position = -1;
      for (let i = 0; i < handler.length; i++) {
        if (handler[i] === fn) position = i;
        break;
      }
      if (position !== -1) {
        // 删除对应的fn
        handler.splice(position, 1);
        // 如果清除后只有一个函数,那么取消数组,以函数形式保存
        if (handler.length === 1) {
          this._events.set(type, handler[0]);
        }
      } else {
        return this;
      }
    }
  }

  emit(type, ...args) {
    let handler = this._event.get(type);
    // 如果没有handler，说明没有监听type事件，直接返回false
    if (!handler) return false;
    // 如果handler是一个数组，需要遍历数组依次调用
    if (Array.isArray(handler)) {  
      for (let i = 0; i < handler.length; i++) {
        if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
      }
    } else {
      if (args.length > 0) {
        handler.apply(this, args);
      } else {
        handler.call(this);
      }
    }
    return true;
  }
}
```



### 手写instanceof

```js
function MyInstance(instanceObj, func) {
  // 获取实例instanceObj的__proto__
  let protoObj = Object.getPrototypeOf(instanceObj);
  while (true) {
    // 沿着原型链查不到__proto__，说明已经查到了原型链顶端，此时还找不到当前类，返回false
    if (protoObj === null) return false;
    // 在当前实例对象的原型链上，找到了当前类
    if (protoObj === func.prototype) return true;
    // 沿着原型链__proto__一层一层向上查
    protoObj = Object.getPrototypeOf(protoObj);
  }
}
```



### 手写new

```js
function MyNew(fn, ...args) {
  // 创建一个对象（实例），且该对象__proto__指向F的prototype
  let instance = Object.create(fn.prototype);
  // 改变this的指向
  let res = fn.apply(instance, args);
  // 确保返回的结果是一个对象（万一fn不是构造函数）
  return typeof res === 'object' ? res : instance;
}
```



### 手写Object.create()

```js
// 该方法创建一个对象，且该对象的__proto__指向传入的参数proto
Object.prototype.myCreate = (proto) => {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



### 手写call

```js
Function.prototype.myCall =  function(context = window, ...args) {
  // 如果非函数调用myCall，抛出错误
  if (typeof this !== 'function') {
    throw new Error('Not function!');
  }
  // 使用Symbol定义唯一的属性
  let key = Symbol('fn');
  context[key] = this;
  let res = context[key](...args);
  // 删除context[key]释放内存，否则context的属性会越来越多
  delete context[key];
  return res;
}
```

手写apply与手写call是一样的，只需要修改传入参数的方式：

```js
let res = context[key](args);
```



### 手写bind

```js
Function.prototype.myBind = function(context = window, ...outerArgs) {
  // 非函数调用，报错
  if (typeof this !== 'function') {
    throw new Error('Not a function!');
  }
  // 保存this
  let self = this;
  return function F(...innerArgs) {
    // 如果是new的方式，这里的this与self已经不是同一个概念了
    if (this instanceof F) {
      return new self(...outerArgs, ...innerArgs);
    }
    return self.call(context, ...outerArgs, ...innerArgs);
  }
}

let obj = {
  name: 'lujiafeng'
};
function a(name, age) {
  this.name = name;
  this.age = age;
}
const fn = a.bind(obj, 'lilinqi', 18);
const ins = new fn();
console.log(ins);
console.log(obj);
```



### 判断类型

```js
let class2type = {};
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) 

function type(obj) {
	if (obj == null) return String(obj);
	return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj;
}
```



### `JS`实现多行省略(不重要)

```html
<div class="box">
  <p class="p" rows='3'>这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字这里有好多字</p>
</div>

<script>
  // 获取需要设置多行省略的标签
  const elBoxs = document.getElementsByClassName('p');
  const elBoxsLength = elBoxs.length;

  // 没有使用forEach(有些浏览器不兼容)和map（标签数组不能使用map的方法）
  for(let i = 0; i < elBoxsLength; i += 1) {
    const el = elBoxs[i];
    let text = el.innerHTML;
    // 需要在第几行省略，是否支持webkitLineClamp属性
    let options = {
      rows: parseInt(el.getAttribute('rows')),
      isSupportlineCamp: `${el.style.webkitLineClamp}` !== 'undefined',
    };

    // 设置需要省略的属性及字体的两端对齐的样式
    el.style.overflow = 'hidden';
    el.style.textOverflow = 'ellipsis';
    el.style.wordBreak = 'break-all';
    el.style.wordWrap = 'break-word';
    el.style.textAlign = 'justify';

    // 支持webkitLineClamp的话直接使用浏览器css样式设置省略号（safari不是很支持，可以直接使用js计算方式），否则通过计算方式
    if(options.isSupportlineCamp) {
      el.style.webkitLineClamp = options.rows;
      el.style.display = '-webkit-box';
      el.style.webkitBoxOrient = 'vertical';
    } else {
      const heightStr = getCurrentStyle(el, 'height');
      const height = getNumber(heightStr);
      const maxHeight = getMaxHeight(el, options.rows, text);
      if(height > maxHeight) {
        subStrChar(el, maxHeight, text);
      } else {
        el.innerHTML = text;
      }
    }
  };

  // 截取字符串，从第一个开始，当前高度大于最大高度时，截取到前一个字符；
  function subStrChar(el, maxHeight, text) {
    console.log(maxHeight);
    let end = false;
    let i = 0;
    while(!end) {
      i++;
      el.innerHTML = text.substring(0, i) + '...';
      const currentHeightStr = getCurrentStyle(el, 'height');
      const currentHeight = getNumber(currentHeightStr);
      if(currentHeight > maxHeight) {
        el.innerHTML = text.substring(0, i - 1) + '...';
        end = true;
      }
      if(i >= text.length) {
        break;
      }
    }
  }

  // 获取最大高度，当line-height为normal的时候，对标签塞入字符，获取一行的行高
  function getMaxHeight(el, rows, text) {
    const lineHeight = getCurrentStyle(el, 'lineHeight');
    let number = 0;

    if(lineHeight === 'normal') {
      let index = 0;
      do {
        el.innerHTML = text[index++];
      } while(!getNumber(getCurrentStyle(el, 'height')));
      number = getNumber(getCurrentStyle(el, 'height'));
    } else {
      number = getNumber(lineHeight);
    }

    return number * rows;
  }

  // 获取当前元素的属性值
  function getCurrentStyle(el, elAttr) {
    // getComputedStyle获取元素的所有CSS属性的值
    return window.getComputedStyle(el)[elAttr]
  }

  // 将获取的字符串值变成向上取整成数字
  function getNumber(str) {
    let number = parseFloat(str);
    return Math.ceil(number)
  }
</script>
```



### 你在你的项目中遇到过什么兼容性处理?

1. 后端返回`2021-06-11`这样字符串日期,在安卓上使用`new Date`是正常可以获取时间格式的，但是在`ios`上使用`new Date`会报错，解决方案是把`-`转成`/`,即`new Date('2021/06-11')`;

2. 针对具有刘海屏或底部菜单横条的设备,进行兼容性处理,否则页面布局往往不符合需求

   ```css
   {html{--ion-safe-area-top:var(--ion-statusbar-padding)}}@supports (padding-top:constant(safe-area-inset-top)){html{--ion-safe-area-top:constant(safe-area-inset-top);--ion-safe-area-bottom:constant(safe-area-inset-bottom);--ion-safe-area-left:constant(safe-area-inset-left);--ion-safe-area-right:constant(safe-area-inset-right)}}@supports (padding-top:env(safe-area-inset-top)){html{--ion-safe-area-top:env(safe-area-inset-top);--ion-safe-area-bottom:env(safe-area-inset-bottom);--ion-safe-area-left:env(safe-area-inset-left);--ion-safe-area-right:env(safe-area-inset-right)}}
   ```

3. `ios`系统会将数字当成电话号码,因此会变色,解决方式是在`index.html`的`head`中添加:

   ```xml
   <meta name="format-detection" content="telephone=no"> 
   <meta http-equiv="x-rim-auto-match" content="none">
   ```

4. `input`框聚焦，`ios`会出现`outline`或者阴影，安卓显示正常,解决方式是

   ```css
   input:focus{outline:none}  //去除外边框
   input{-webkit-appearance: none;}
   ```

5. 



### 浏览器页面渲染流程
