## `HTTP`协议的主要特点

- 简单快速

  每个资源(比如图片,页面)都是通过`url`来定位.这都是固定的,在`http`协议中,处理起来也比较简单,想访问什么资源,直接输入`url`即可.

- 灵活

  `http`协议的头部有一个数据类型,通过`http`协议,可以完成不同数据类型的传输.

- `无连接`

  连接一次就会断开,不会继续保持连接.

- `无状态`

  客户端和服务器端是两种身份.第一次请求结束后,就断开了;第二次请求时,服务器端并没有记住之前的状态,也就是说,服务器端无法区分客户端;

  有的时候,我们访问网站时,网站能记住我们的账号,这是通过其他手段(比如`session`)做到的,并不是`http`协议能做到的.



## `HTTP`报文的组成部分

`http`报文包括:`请求报文`和`响应报文`.

![报文类型](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.png)

- 请求报文包括:

  ![请求报文](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png)

  1. 请求行:包括请求方法,请求`URL`,`HTTP`协议及版本;
  2. 请求头
  3. 空行:当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体
  4. 请求体:数据部分



- 响应报文包括:

  ![响应报文](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png)

  1. 状态行：`http`协议及版本、状态码及状态描述。
  2. 响应头
  3. 空行
  4. 响应体



### `HTTP`请求头

| 请求头            | 举例                                                         | 说明                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Accept`          | `Accept: image/jpeg, application/x-ms-application, ..., */*` | 可接受的响应内容类型`(Content-Type)`                         |
| `Referer`         | `Referer: http://localhost:8080/user/register.html?code=100` | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。`Referer`其实是`Referrer`这个单词，但`RFC`制作标准时给拼错了，后来也就将错就错使用`Referer`了。 |
| `Accept-Language` | `Accept-Language: zh-CN`                                     | 可接受的响应内容语言列表                                     |
| `User-Agent`      | `User-Agent: Mozilla/4.0`                                    | 浏览器的身份标识字符串                                       |
| `Content-Type`    | `Content-Type: application/x-www-form-urlencoded`            | 请求体的MIME类型 (用于`POST`和`PUT`请求中)                   |
| `Host`            | `Host: localhost:8080`                                       | 表示服务器的域名以及服务器所监听的端口号.如果所请求的端口是对应的服务的标准端口`80`,则端口号可以省略 |
| `Connection`      | `Connection: Keep-Alive`                                     | 客户端(浏览器)想要优先使用的连接类型                         |
| `Cache-Control`   | `Cache-Control: no-cache`                                    | 用来指定当前的请求/回复中的,是否使用缓存机制。               |
| `Cookie`          | `Cookie: JSESSIONID=215R487HFDSH4`                           | 由之前服务器通过`Set-Cookie`设置的一个`HTTP协议Cookie`       |



## `HTTP`方法

- `GET`：获取资源
- `POST`：传输资源
- `PUT`：更新资源
- `DELETE`：删除资源
- `HEAD`：获得报文首部

### `GET`和`POST`的区别

1. 浏览器回退时,`GET`不会重新请求,但是`POST`会重新请求;
2. `GET`请求会被浏览器主动缓存,而`POST`不会;
3. `GET`请求的参数,会被保留在浏览器的历史记录里(因为参数都是在URL上显示的，所以会留下历史记录),而`POST`不会.做业务时要注意,为了防止`CSRF`攻击,很多公司把`GET`统一改成了`POST`.
4. `GET`请求在`url`中传递的参数有大小限制,基本是`2kb`,不同的浏览器略有不同;而`POST`没有限制;
5. `GET`的参数是直接暴露在`url`上的,相对不安全.而`POST`是放在请求体中的.



## `HTTP`状态码

- 1**：信息，服务器收到请求，需要请求者继续执行操作

- 2**：成功，表示请求已被成功接收并处理

- 3**：重定向，需要进一步的操作以完成请求

- 4**：客户端错误，请求包含语法错误或者无法完成请求

- 5**：服务器错误，服务器在处理请求的过程中发生了错误

### 常见的`http`状态码

| 状态码 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | `OK`,请求成功                                                |
| 301    | `Moved Permanently`,目标资源永久转移到一个新的`url`          |
| 302    | `Found,`目标资源临时转移到另一个`url`                        |
| 303    | `See Other`,表示服务器要讲浏览器重定向到另一个资源,这个资源的`url`会被写在响应头的`Location`字段.从语义上讲,重定向到的资源并不是你所请求的资源,而是对所请求资源的一些描述;<br />303常用于将`post`请求重定向到`get`请求,比如上传了一份个人信息,服务器返回一个303响应,将页面导向一个上传成功的页面;<br />不管原请求是什么方法,重定向请求的方法都是`get`; |
| 304    | `Not Modified`,客户端缓存的资源远端未修改,表示客户端可以使用当前缓存 |
| 305    | `Use Proxy`,被请求的资源需要使用指定的代理访问               |
| 307    | `Temporary Redirect`,307定义与302一致,区别在于307不允许浏览器将原本`post`的请求重定向到`get`请求 |
| 308    | `Permanent Redirect`,308定义与301一致,区别在于308不允许浏览器将原本`post`的请求重定向到`get`请求 |
| 400    | `Bad Request`,客户端请求有语法错误                           |
| 401    | `Unauthorized`,没有权限                                      |
| 403    | `Forbidden`, 禁止,服务器理解客户端请求,但是拒绝处理          |
| 404    | `Not Found`,请求的资源不存在                                 |
| 408    | `Request Timeout`,请求超时                                   |
| 500    | `Interval Server Error`,内部服务器错误                       |
| 502    | `Bad Gateway`,充当网管或代理的服务器从远端服务器接收到了一个无效请求 |
| 504    | `Gateway Timeout`,充当网关或代理的服务器,未及时从远端服务器获取请求 |



## `HTTP`连接的几种方式

### 轮询

- 轮询:`HTTP1.0`中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如`1`秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。

参考自:https://zhuanlan.zhihu.com/p/42230117 

`HTTP1.0`,每次发送请求都要建立一次`TCP`连接:


![img](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/http1.0%E7%9A%84%E8%BF%9E%E6%8E%A5.png)

当HTML页面需要请求多个资源时，每一个请求都需要建立一个`TCP`连接和断开`TCP`连接,增加了开销：

![img](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/http1.0%E7%9A%84%E8%BF%9E%E6%8E%A52.png)

于是，`HTTP1.1`提出了**持久连接**：

![img](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/http1.1%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png)

### 持久连接

- 持久连接又叫长连接;

- 持久连接的特点：客户端只请求一次,服务器会继续保持连接,当再次请求时,避免重新建立连接.任意一端没有明确提出断开连接，则保持`TCP`连接状态。

- `HTTP/1.1` 中所有连接默认都是持久连接,通过使用`Connection: keep-alive`进行持久连接,

- 持久连接的好处：减少`TCP`连接的重复建立和断开造成的额外开销，减轻客户端和服务器的压力。

- 在一次`TCP`连接中可以完成多个`HTTP`请求,但是每个请求都要单独发`Header`;

- `Keep-alive`不会永久保持连接,它有一个保持时间,可以在不同的服务器软件(如`Apache`)中设定这个时间.

- `Keep-alive`存在两个问题:

  一个是`HTTP 1.1` 基于串行文件传输数据，因此这些请求必须是有序的，所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少;

  另一个是最大并发数问题，假设我们在` Apache` 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50

虽然持久连接减少了`TCP`连接，但是一个一个的请求和接收还是太慢，于是有了**管线化**：

![img](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E7%AE%A1%E7%BA%BF%E5%8C%96.png)

### 长连接中的管线化

- .`HTTP`管线化`(pipelining)`是将多个`HTTP`请求整批提交的技术，而在传送过程中不需要先等待服务端的响应.管线化机制须`长连接`完成，因此需要`HTTP/1.1`支持此技术，并且只有`GET`和`HEAD`请求可以进行管线化，而`POST`则有所限制。此外，初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持`HTTP/1.1`版本的协议。
- 浏览器将`HTTP`请求大批提交可大幅缩短页面的加载时间，特别是在传输延迟较高的情况下（如卫星连接）。此技术之关键在于多个`HTTP`的请求消息可以同时塞入一个`TCP`分组中，所以只提交一个分组即可同时发出多个请求，借此可减少网络上多余的分组并降低线路负载。

管线化技术比持久连接又快了一些,然而管线化在接收`response`返回时,也必须依顺序接收,如果前面的请求遇到了阻塞,后面的请求即使已经处理完毕了,仍然需要等待阻塞的请求处理完成.如下图,第一个请求阻塞后,后面的请求都需要等待,即队头阻塞`(Head of line blocking)`

![管线化阻塞](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E7%AE%A1%E7%BA%BF%E5%8C%96%E9%98%BB%E5%A1%9E.png)

为了解决上述阻塞问题,`HTTP2.0`提出了多路复用`(Multiplexing)`技术.

### `HTTP2.0`中的多路复用

`HTTP2.0`中**将多个请求复用同一个TCP链接中**，将一个TCP连接分为若干个流`(stream)`，每个流中可以传输若干消息`(message)`，每个消息由若干最小的二进制帧`(Frame)`组成。也就是将每个`request-response`拆分为了细小的二进制帧`Frame`，这样即使一个请求被阻塞了，也不会影响其他请求，如图中第四种情况所示。

![多路复用](https://gitee.com/ljf52007/note/raw/master/interview/interview_Q/Http_Q.assets/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

### 

##  `HTTP1.0`和`HTTP1.1`的一些区别

- `缓存处理`，`HTTP1.0`中主要使用`Last-Modified`，`Expires` 来做为缓存判断的标准，`HTTP1.1`则引入了更多的缓存控制策略：`ETag，Cache-Control…`
- `带宽优化及网络连接的使用`，`HTTP1.1`支持断点续传，即返回码是`206`（`Partial Content`）
- `错误通知的管理`，在`HTTP1.1`中新增了`24`个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突；`410（Gone）`表示服务器上的某个资源被永久性的删除…
- `Host头处理`，在`HTTP1.0`中认为每台服务器都绑定一个唯一的`IP`地址，因此，请求消息中的URL并没有传递主机名（`hostname`）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（`Multi-homed Web Servers`），并且它们共享一个`IP`地址。`HTTP1.1`的请求消息和响应消息都应支持`Host`头域，且请求消息中如果没有`Host`头域会报告一个错误（`400 Bad Request`）
- `长连接`，`HTTP1.1`中默认开启`Connection： keep-alive`，一定程度上弥补了`HTTP1.0`每次请求都要创建连接的缺点



## `HTTP2.0`和`HTTP1.X`相比的新特性

- `新的二进制格式（Binary Format）`，`HTTP1.x`的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认`0`和`1`的组合，基于这种考虑`HTTP2.0`的协议解析决定采用二进制格式，实现方便且健壮
- `header压缩`，`HTTP1.x`的`header`带有大量信息，而且每次都要重复发送，`HTTP2.0`使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，又减小了需要传输的大小
- `服务端推送（server push）`，例如我的网页有一个`style.css`的请求，在客户端收到`style.css`数据的同时，服务端会将`style.js`的文件推送给客户端，当客户端再次尝试获取`style.js`时就可以直接从缓存中获取到，不用再发请求了

```text
// 通过在应用生成HTTP响应头信息中设置Link命令
Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as=image
```

- 多路复用`(MultiPlexing)`
  - `HTTP/1.0` 每次请求响应，建立一个`TCP`连接，用完关闭
  - `HTTP/1.1` 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
  - `HTTP/2.0` 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；



## `HTTP`和`HTTPS`

### `HTTP`和`HTTPS`的区别

`HTTP（Hyper Text Transfer Protocol，超文本传输协议）`被用于`在web`浏览器和网站服务器之间传递信息，`HTTP`协议以明文的方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，`HTTP`协议不适合传输一些敏感信息，比如：信用卡号，密码等支付信息。

`HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer，安全套接字超文本传输协议）`，为了数据传输的安全，`HTTPS`在`HTTP`的基础上加入了     `SSL/TLS`，依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。其`中SSL（Secure Socket Layer，安全套接层）`，`TLS（Transport Layer Securit，传输层安全协议）`，`SSL 3.0`和`TLS 1.0`差别很小，在`HTTPS`通信中具体使用哪一个还要看客户端和服务端的支持程度，二者在网络模型中位于哪一层.

**区别：**

（1）`HTTPS`协议需要`CA`申请证书，一般免费证书比较少，所以需要一定费用

（2）`HTTP`是超文本传输协议，信息室明文传输，`HTTPS`则是具有安全性的`SSL`加密传输协议

（3）`HTTP`和`HTTPS`使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443

（4）`HTTP`连接很简单，是无状态的；`HTTPS`协议是由`HTTP+SS`L协议构建的可进行加密传输、身份认证的网络协议，比较安全。

（5）谷歌搜索引擎算法中，比起同等`HTTP`网站，采用`HTTPS`加密的网站在搜索结果中排名会更高



### 客户端使用`HTTPS`方式与`web`服务器通信的步骤：

（1）客户使用`HTTPS`的`URL`访问`web`服务器，要求与`web`服务器建立`SSL`连接

（2）`web`服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端

（3）客户端的浏览器与`web`服务器开始协商`SSL`连接的安全等级，也就是信息的加密等级

（4）客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站

（5）`web`服务器利用自己的私钥解密出会话秘钥

（6）`web`服务器利用会话秘钥加密与客户端之间的通信



### 如何从`HTTP`切换到`HTTPS`？

（1）需要将页面中所有的链接（例如`js,css,图片`等链接）都由`http`改为`https`

（2）一般情况下会建议保留`HTTP`，所以在切换的时候可以做`HTTP`和`HTTPS`的兼容，具体实现方式是：去掉页面连接中的`http`头部，这样可以自动匹配`HTTP`头和`HTTPS`头



## 七 一些零散的面试题

### 有关`HTTP`缓存的首部字段说一下

- `HTTP/1.0` `Expires`
- `HTTP/1.1` `Cache-Control`，`last-modified/if-modified-since`，`ETag/if-match`



### `HTTP`中的`keep-alive`有了解吗？

`HTTP/1.1`中默认开启长连接，在首部的`Connection`字段中设置，防止传输完之后就断开`TCP`，让`TCP`可以传递多条数据



### 在一次传输中它是如何保证每个数据包之间的顺序的？

`TCP`会将每个数据包标记一个编码



### 为什么说`GET`会留下历史记录?

因为参数都是在`URL`上显示的，所以会留下历史记录



### `GET`可以上传图片吗?

`GET`也行，但是一般不用`GET`，`GET`会把诸如`input`的信息都打印在`url`上，加上`URL`的长度受浏览器限制



### `GET`就一定是幂等的吗?

不一定，如果用`GET`来做了`POST`的事情，那么它就不是幂等的



### 为什么说`POST`相对安全一些

1. 参数放在请求体中
2. 除`FF`浏览器外，它会先发送两次请求，只有在第一次请求响应之后才会发送带有请求体的第二次请求



### 如果一个按钮点击进行`GET`请求会留下历史记录吗？

`Form`提交才有，但在开发者工具的`network`中都有记录的