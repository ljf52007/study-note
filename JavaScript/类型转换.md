首先明确,在`js`中类型转换只有三种情况,分别是

- 转换为布尔值
- 转换为数字
- 转换为字符串

## 转换为布尔值

在条件判断时,除了`undefined`,`null`,`0`,`-0`,`NaN`,`''`,`false`,其他所有值都转为`true`,包括所有对象;

## 对象转原始类型

对象在转换类型的时候,会调用内置的`[[ToPrimitive]]`函数,对于该函数来说,算法逻辑一般如下:

- 如果已经是原始类型,不进行转换;
- 调用`x.valueOf()`,如果转换为基础类型,返回转换的值;
- 调用`x.toString()`,如果转换为基础类型,就返回转换的值;
- 如果都没有返回原始类型,就会报错.

当然,也可以重写`Symbol.toPrimitive`,该方法在转原始类型时调用优先级最高.

```js
const a = {
    valueOf() {
        return 0;
    },
    toString() {
        return '1';
    },
    [Symbol.toPrimitive]() {
        return 2;
    }
}
console.log(1 + a); // 3
```



## 四则运算

### 加法运算

对于`+ - * /`四则运算来说,`+`是比较特殊的,它有如下特点:

- `+`运算中,如果其中一方为字符串,另一方也转换为字符串;
- `+`运算中,如果其中一方不是字符串或者数字,那么将它转换为数字或者字符串;

来看几个例子

```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
'a' + + 'b'
```

- 对于第一行代码来说,触发特点一，所以将数字 `1` 转换为字符串，得到结果 `'11'`
- 对于第二行代码来说,触发特点二，所以将 `true` 转为数字 `1`
- 对于第三行代码来说,触发特点二，所以将数组通过 `toString`转为字符串 `1,2,3`，得到结果 `41,2,3`
- 第四行代码比较特殊,因为`+ 'b'`等于`NaN`,所以结果为`'aNaN'`.



### 加法以外的四则运算

对于除了加法的运算符来说,只要其中一方是数字,那么另一方也会被转换为数字

```js
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```



## 比较运算

- 如果是对象,就通过`toPrimitive`转换对象;
- 如果是字符串,就通过`unicode`字符索引来比较;

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```
